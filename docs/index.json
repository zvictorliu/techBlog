[{"categories":null,"content":"在现有主题上的修改 ","date":"2024-03-31","objectID":"/techBlog/posts/custom/:0:0","tags":null,"title":"Custom","uri":"/techBlog/posts/custom/"},{"categories":null,"content":"Go 语言 {{ }}是go语言模板引擎，里面的内容是访问的go的一些东西 ","date":"2024-03-31","objectID":"/techBlog/posts/custom/:1:0","tags":null,"title":"Custom","uri":"/techBlog/posts/custom/"},{"categories":null,"content":"不满 主要还是配色太俗气 ","date":"2024-03-31","objectID":"/techBlog/posts/custom/:2:0","tags":null,"title":"Custom","uri":"/techBlog/posts/custom/"},{"categories":null,"content":"行内代码 行内块的高亮感觉太宽，而且高亮也觉得不太舒服 hello hello ","date":"2024-03-31","objectID":"/techBlog/posts/custom/:2:1","tags":null,"title":"Custom","uri":"/techBlog/posts/custom/"},{"categories":null,"content":"块引用 $blockquote-color to be or not to be 颜色太喧宾夺主 blockquote { display: block; border-left: .5rem solid $blockquote-color; // 宽度 线型 颜色 background-color: rgba($blockquote-color, .2); padding: .25rem .75rem; // 靠近上下边界 坐标靠近left的边距 margin: 1rem 0; // 和上下元素的边距 [theme=dark] \u0026 { border-left-color: $blockquote-color-dark; background-color: rgba($blockquote-color-dark, .2); } } $blockquote-color的颜色实际是border-left的，bakcground-color才是真的 高度不知道怎么修改 ","date":"2024-03-31","objectID":"/techBlog/posts/custom/:2:2","tags":null,"title":"Custom","uri":"/techBlog/posts/custom/"},{"categories":null,"content":"代码 修改背景 高亮颜色更简洁 // Color map of the code highlight $code-highlight-color-map: ( /* Parentheses */ \"p\": #a9a9b3, /* Keyword */ \"k\": #b501a9, /* KeywordConstant */ \"kc\": #b501a9, /* KeywordDeclaration */ \"kd\": #b501a9, /* KeywordNamespace */ \"kn\": #b501a9, /* KeywordPseudo */ \"kp\": #b501a9, /* KeywordReserved */ \"kr\": #b501a9, /* KeywordType */ \"kt\": #b501a9, /* Name */ \"n\": #333333, /* NameAttribute */ \"na\": #2b77fa, /* NameBuiltin */ \"nb\": #f74840, /* NameBuiltinPseudo */ \"bp\": #f74840, /* NameClass */ \"nc\": #cb8100, /* NameConstant */ \"no\": #2b77fa, /* NameDecorator */ \"nd\": #0086c1, /* NameEntity */ \"ni\": #2b77fa, /* NameException */ \"ne\": #2b77fa, /* NameFunction */ \"nf\": #2b77fa, /* NameFunctionMagic */ \"fm\": #1ccad6, /* NameLabel */ \"nl\": #2b77fa, /* NameNamespace */ \"nn\": #2b77fa, /* NameOther */ \"nx\": #333333, /* NameProperty */ \"py\": #2b77fa, /* NameTag */ \"nt\": #2b77fa, /* NameVariable */ \"nv\": #2b77fa, /* NameVariableClass */ \"vc\": #2b77fa, /* NameVariableGlobal */ \"vg\": #2b77fa, /* NameVariableInstance */ \"vi\": #2b77fa, /* NameVariableMagic */ \"vm\": #2b77fa, /* Literal */ \"l\": #2aa198, /* LiteralDate */ \"ld\": #2aa198, /* LiteralString */ \"s\": #24a443, /* LiteralStringAffix */ \"sa\": #24a443, /* LiteralStringBacktick */ \"sb\": #24a443, /* LiteralStringChar */ \"sc\": #24a443, /* LiteralStringDelimiter */ \"dl\": #24a443, /* LiteralStringDoc */ \"sd\": #24a443, /* LiteralStringDouble */ \"s2\": #24a443, /* LiteralStringEscape */ \"se\": #24a443, /* LiteralStringHeredoc */ \"sh\": #24a443, /* LiteralStringInterpol */ \"si\": #24a443, /* LiteralStringOther */ \"sx\": #24a443, /* LiteralStringRegex */ \"sr\": #24a443, /* LiteralStringSingle */ \"s1\": #24a443, /* LiteralStringSymbol */ \"ss\": #24a443, /* LiteralNumber */ \"m\": #e2893c, /* LiteralNumberBin */ \"mb\": #e2893c, /* LiteralNumberFloat */ \"mf\": #e2893c, /* LiteralNumberHex */ \"mh\": #e2893c, /* LiteralNumberInteger */ \"mi\": #e2893c, /* LiteralNumberIntegerLong */ \"il\": #e2893c, /* LiteralNumberOct */ \"mo\": #e2893c, /* Operator */ \"o\": #f19b04, /* OperatorWord */ \"ow\": #b501a9, /* Comment */ \"c\": #a0a1a8, /* CommentHashbang */ \"ch\": #a0a1a8, /* CommentMultiline */ \"cm\": #a0a1a8, /* CommentSingle */ \"c1\": #a0a1a8, /* CommentSpecial */ \"cs\": #a0a1a8, /* CommentPreproc */ \"cp\": #a0a1a8, /* CommentPreprocFile */ \"cpf\": #a0a1a8, /* Generic */ \"g\": #e72d40, /* GenericDeleted */ \"gd\": #e72d40, /* GenericEmph */ \"ge\": #e72d40, /* GenericError */ \"gr\": #e72d40, /* GenericHeading */ \"gh\": #e72d40, /* GenericInserted */ \"gi\": #e72d40, /* GenericOutput */ \"go\": #e72d40, /* GenericPrompt */ \"gp\": #e72d40, /* GenericStrong */ \"gs\": #e72d40, /* GenericSubheading */ \"gu\": #e72d40, /* GenericTraceback */ \"gt\": #e72d40, /* TextWhitespace */ \"w\": #bbbbbb, ) !default; #include \u003ciostream\u003e using namespace std; #define hello 2 int main(){ int a = 0; char ch*; for (int i = 0; i \u003c 9; i++){ cout \u003c\u003c i \u003c\u003c endl; break; } return 0 } import os PI = 3.14 def func(var : int) -\u003e int: a = 0 ch = 'hello\\n' pass class Hell0(): def __init__(self): print('hello') 等于号 ","date":"2024-03-31","objectID":"/techBlog/posts/custom/:3:0","tags":null,"title":"Custom","uri":"/techBlog/posts/custom/"},{"categories":null,"content":"url link 颜色吸管 - 在线颜色工具 - PhotoKit.com https://photokit.com/colors/eyedropper/?lang=zh 和标题是一个样 ","date":"2024-03-31","objectID":"/techBlog/posts/custom/:4:0","tags":null,"title":"Custom","uri":"/techBlog/posts/custom/"},{"categories":null,"content":"article 横线 想加粗这里的虚线 但似乎这个不是这里能修改的，它并不是一个div ","date":"2024-03-31","objectID":"/techBlog/posts/custom/:5:0","tags":null,"title":"Custom","uri":"/techBlog/posts/custom/"},{"categories":["Development"],"content":"基本和ROS1是一样的 ROS2 核心概念 ","date":"2024-03-16","objectID":"/techBlog/posts/ros2-chap2/:0:0","tags":["ROS"],"title":"ROS2 核心概念","uri":"/techBlog/posts/ros2-chap2/"},{"categories":["Development"],"content":"workspace 需要注意这个 - ws/\r- src/\r- install/\r- build/\r- log src中的代码被编译，中间文件在build，生成的文件在install 开源的代码就是clone到src中，一般这些代码会有自己的依赖项，这些不同项目的代码就是一个个功能包package 有python包可以帮助安装依赖：rosdepc（鱼香开发的），注意这不是ros2内部命令而是python的，所以风格和ros2不一样 sudo apt install python3-rosdep2 sudo rosdepc init \u0026\u0026 rosdepc update rosdepc install -i --from-path src --rosdistro humble -y # 自动搜索src下的安装包 依赖项dependency安装好后才开始编译 ros2引入了新的编译工具colcon，而ros1是catkin sudo apt install python3-colcon-ros 然后在ws根目录执行编译 colcon build 如果报错： ModuleNotFoundError: No module named 'em' 指的是python的empy包 pip install empy==3.3.2 #版本问题\rpython -m pip install lark-parser 还要将当前的工作空间告知系统，配置环境变量 $ source install/local_setup.sh # 仅在当前终端生效 $ echo \" source ~/\u003cws\u003e/install/local_setup.sh\" \u003e\u003e ~/.bashrc # 所有终端均生效 ","date":"2024-03-16","objectID":"/techBlog/posts/ros2-chap2/:1:0","tags":["ROS"],"title":"ROS2 核心概念","uri":"/techBlog/posts/ros2-chap2/"},{"categories":["Development"],"content":"package 除了从别处下载功能包之外，也还可以自己创建 $ cd src/ # 需要切到src，但是src也不是可以自定义名字，colcon是默认在这里找的 $ ros2 pkg create --build-type \u003cbuild-type\u003e \u003cpackage_name\u003e 因为ros2可以支持c++和python，因此要选择是哪种build-type，如果使用C++或者C，那这里就跟ament_cmake，如果使用Python，就跟ament_python package.xml 描述该功能包，所以一个package应该是由这个文件来确定的，并不完全受到文件夹分布的影响 \u003ctest_depend\u003eament_copyright\u003c/test_depend\u003e \u003ctest_depend\u003eament_flake8\u003c/test_depend\u003e \u003ctest_depend\u003eament_pep257\u003c/test_depend\u003e \u003ctest_depend\u003epython3-pytest\u003c/test_depend\u003e 这些就是它的依赖项 C++的还有一个CMakeList.txt，Python则没有(Python是解释语言) Python对应的是setup.cfg setup.py文件 ","date":"2024-03-16","objectID":"/techBlog/posts/ros2-chap2/:2:0","tags":["ROS"],"title":"ROS2 核心概念","uri":"/techBlog/posts/ros2-chap2/"},{"categories":["Development"],"content":"node 每个节点都是一个独立运行的可执行文件，是一个具体的任务进程 支持不同语言，不同平台，不同主机 名称要唯一 package文件夹中有源码，对于python版本，需要指明节点程序的入口，这是在setup.py文件中的 entry_points={ 'console_scripts': [ 'node_helloworld = learning_node.node_helloworld:main', 'node_helloworld_class = learning_node.node_helloworld_class:main', 'node_object = learning_node.node_object:main', 'node_object_webcam = learning_node.node_object_webcam:main', ], }, 这实际是指明了该功能包下四个节点和它们对应的程序入口 colcon build会依照这个，会将源文件复制到install中的一个文件夹，再生成一些带有描述性质的可执行python代码 /ws\rinstall/\r\u003cpackageName\u003e/\rlib/\r\u003cpackageName\u003e # 生成代码\r\u003cpython\u003e # 源码 每次修改代码就需要重新编译，否则就还是执行池子里的旧版 如果编程时用的相对路径，它还能正确找到吗？ ","date":"2024-03-16","objectID":"/techBlog/posts/ros2-chap2/:3:0","tags":["ROS"],"title":"ROS2 核心概念","uri":"/techBlog/posts/ros2-chap2/"},{"categories":["Development"],"content":"topic 节点之间的通信，两种方式，一种是topic，一种是service topic遵循发布/订阅模型，采用.msg的消息结构 发布/订阅模型 可以多对多通信，只是需要注意优先级 编程时的思路是： 编程接口初始化 创建节点并初始化 创建发布者对象 创建并填充话题消息 发布话题消息 销毁节点并关闭接口 一般都会有一个定时器对象，以及相应的callback函数，这样才能持续工作 ","date":"2024-03-16","objectID":"/techBlog/posts/ros2-chap2/:4:0","tags":["ROS"],"title":"ROS2 核心概念","uri":"/techBlog/posts/ros2-chap2/"},{"categories":["Development"],"content":"service","date":"2024-03-16","objectID":"/techBlog/posts/ros2-chap2/:5:0","tags":["ROS"],"title":"ROS2 核心概念","uri":"/techBlog/posts/ros2-chap2/"},{"categories":["Development"],"content":"ROS学习笔记 ROS2系统架构 要区分ROS2和ROS1，二者还是有许多区别的，ROS2是对ROS1的推到重来、重新设计 由于一些开源代码时间比较久，大概率是ROS1的，它们的命令是有一些区别的，好在容易区分 ROS有诸多发行版，但是LTS目前是2022年发布的 Humble Hawksbill ","date":"2024-03-16","objectID":"/techBlog/posts/ros2-chap1/:0:0","tags":["ROS"],"title":"ROS2 系统架构","uri":"/techBlog/posts/ros2-chap1/"},{"categories":["Development"],"content":"ROS2安装 # 设置编码 $ sudo apt update \u0026\u0026 sudo apt install locales $ sudo locale-gen en_US en_US.UTF-8 $ sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 $ export LANG=en_US.UTF-8 $ sudo apt update # 生效 # 添加ROS软件源 $ sudo apt install curl gnupg lsb-release # 一些安装工具 $ sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg # 设置密钥 $ echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release \u0026\u0026 echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list \u003e /dev/null # 配置软件源 $ sudo apt update $ sudo apt upgrade sudo apt install ros-humble-desktop 有三个版本：desktop-full desktop base # 环境变量 $ source /opt/ros/humble/setup.bash #也是安装位置 $ echo \" source /opt/ros/humble/setup.bash\" \u003e\u003e ~/.bashrc ","date":"2024-03-16","objectID":"/techBlog/posts/ros2-chap1/:1:0","tags":["ROS"],"title":"ROS2 系统架构","uri":"/techBlog/posts/ros2-chap1/"},{"categories":["Development"],"content":"仿真 需要多个终端下达指令 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 注意要在命令行上按才有效，类似于从终端输入 从这里输入 放置另一只海龟是需要调用服务： ros2 service call /spawn turtlesim/srv/Spawn \"{x: 2, y: 2, theta: 0.2, name: ''}\" #空就是默认名 ","date":"2024-03-16","objectID":"/techBlog/posts/ros2-chap1/:2:0","tags":["ROS"],"title":"ROS2 系统架构","uri":"/techBlog/posts/ros2-chap1/"},{"categories":["Development"],"content":"命令规范 ros2 \u003cobj/cmd\u003e # 不加后面的参数就是帮助说明 而在ros1里面则没有前面的ros2总命令，而是细分了，即 rosrun rosnode rosbag ... 常用的： ros2 run \u003cpkg\u003e \u003cnode\u003e # 运行一个node ros2 node list #当前正在运行的Node ros2 node info \u003cpath/to/node\u003e # 查看node信息 ros2 topic list ros2 topic echo \u003cpath/to/topic\u003e ros2 topic pub xxx # 发布消息 ros2 bag record xxx ros2 bag play xxx ","date":"2024-03-16","objectID":"/techBlog/posts/ros2-chap1/:3:0","tags":["ROS"],"title":"ROS2 系统架构","uri":"/techBlog/posts/ros2-chap1/"},{"categories":["Tools"],"content":"将vim改造为一个IDE，接近VSC的程度 Vim配置 ","date":"2024-03-03","objectID":"/techBlog/posts/vim/:0:0","tags":["Vim","Editor"],"title":"Vim配置","uri":"/techBlog/posts/vim/"},{"categories":["Tools"],"content":"插件 可以手动安装插件，安装在~/.vim/pack/\u003cvendor\u003e/start中，不过一般不这样 一般通过插件管理器vim-plug curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 在.vimrc中配置：(以NERDTree为例) call plug#begin() Plug 'preservim/NERDTree' call plug#end() ","date":"2024-03-03","objectID":"/techBlog/posts/vim/:1:0","tags":["Vim","Editor"],"title":"Vim配置","uri":"/techBlog/posts/vim/"},{"categories":["Tools"],"content":"键盘映射 插件的一些命令都比较长，输入不便，因此绑定快捷键是常见的 ","date":"2024-03-03","objectID":"/techBlog/posts/vim/:2:0","tags":["Vim","Editor"],"title":"Vim配置","uri":"/techBlog/posts/vim/"},{"categories":["Tools"],"content":"oh-my-posh 使用基础教程 oh-my-posh oh-my-posh是一种优化shell的prompt的工具，就是这部分 (base) zongwei@V-7000:~ $ ","date":"2024-02-27","objectID":"/techBlog/posts/oh-my-posh/:0:0","tags":["shell"],"title":"Oh My Posh","uri":"/techBlog/posts/oh-my-posh/"},{"categories":["Tools"],"content":"安装oh-my-posh ","date":"2024-02-27","objectID":"/techBlog/posts/oh-my-posh/:1:0","tags":["shell"],"title":"Oh My Posh","uri":"/techBlog/posts/oh-my-posh/"},{"categories":["Tools"],"content":"windows-powershell windows一般是Windows Terminal管理powershell, cmd等shell，Windows Terminal的主题是一回事，而prompt又是另一回事，Windows Terminal配置的一般是字体、背景、输出高亮这些，主题可在https://windowsterminalthemes.dev/ 上复制，然后粘贴到Windows Terminal的配置文件中再选择（Ctrl+Shitf+,打开配置json文件，复制到schemes中) 下载遵照官网指示 winget install JanDeDobbeleer.OhMyPosh -s winget 为了图标的正确显示，需要采用Nerd Fonts，其实就是给系统里添加这种字体，官网的命令行下载反倒有些问题，直接将下载下来的压缩包解压，全选.ttf右键安装即可，然后在Windows Terminal配置为这种字体（设置里面） notepad $PROFILE 进入新建编辑，填入： oh-my-posh init pwsh --config \"$env:POSH_THEMES_PATH\\jandedobbeleer.omp.json\" | Invoke-Expression 可以不要--config的，那样就是默认主题 然后生效： . $PROFILE ","date":"2024-02-27","objectID":"/techBlog/posts/oh-my-posh/:1:1","tags":["shell"],"title":"Oh My Posh","uri":"/techBlog/posts/oh-my-posh/"},{"categories":["Tools"],"content":"wsl-bash 经过踩坑，一定要用brew安装，否则wsl启动会找不到oh-my-posh，若是手动安装的则直接删除文件夹即可 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 记得安装时一定要遵照里面Next Steps里说的要执行的两个命令，即将homebrew的环境变量导入到.bashrc里面，否则会找不到brew 安装oh-my-posh需要确保build-essential和gcc安装(因为要build) 然后： brew install jandedobbeleer/oh-my-posh/oh-my-posh # brew install oh-my-posh 这样将安装成功了，重启shell 写入~/.bashrc中，注意一定是brew shellenv先于oh-my-posh # ~/.bashrc eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\" eval \"$(oh-my-posh init bash --config $(brew --prefix oh-my-posh)/themes/jandedobbeleer.omp.json)\" 重启即可 由于WSL也是由Windows Terminal管理的，所以字体也是和Windows-powershell的方式一样 ","date":"2024-02-27","objectID":"/techBlog/posts/oh-my-posh/:1:2","tags":["shell"],"title":"Oh My Posh","uri":"/techBlog/posts/oh-my-posh/"},{"categories":["Tools"],"content":"linux-bash 和wsl的一样，只是字体安装是要Ubuntu的方式 oh-my-posh也有安装字体的命令，但似乎一般网络连接会有问题，总之它就是把字体安装到系统，然后直接修改Terminal的设置就可以看到了 oh-my-posh font install 奇怪为什么推荐的字体反而不在这里面 ","date":"2024-02-27","objectID":"/techBlog/posts/oh-my-posh/:1:3","tags":["shell"],"title":"Oh My Posh","uri":"/techBlog/posts/oh-my-posh/"},{"categories":["GNSS"],"content":"LAMBDA算法的大概原理和RTKLIB中的代码 LAMBDA算法 ","date":"2024-02-18","objectID":"/techBlog/posts/lambda/:0:0","tags":["RTKLIB"],"title":"LAMBDA算法","uri":"/techBlog/posts/lambda/"},{"categories":["GNSS"],"content":"理论基础 整体的过程是：z变换到新空间以去相关 $\\rightarrow$ 在新空间搜索最佳整数模糊度组合（更高效）$\\rightarrow$ 变换回原空间 ","date":"2024-02-18","objectID":"/techBlog/posts/lambda/:1:0","tags":["RTKLIB"],"title":"LAMBDA算法","uri":"/techBlog/posts/lambda/"},{"categories":["GNSS"],"content":"载波相位测量 理想情况下，卫星在 $t$ 时刻发送其当前的相位信息，至 $t+\\delta t$ 时刻接收机测到，接收机有一个和卫星同步的波，测量即可得到此时卫星上的相位，那么，两者之差 (fraction)乘以波长，加上未知的整数部分 (Ambiguity)即可得到距离 但是由于卫星是运动的，运动过程中距离又在变化，所以还有一个 cycle 部分，接收机对卫星进行信号跟踪一段时间，通过积分可以求出这个cycle $$ Cycle(t+\\delta t) = Int[\\int_{t}^{t + \\delta t} \\delta f ~\\mathrm{dt} + F(t)] $$ 但是如果有短时间遮挡等原因导致时区最终，这里算出来的值就会有误差，就是周跳，周跳有周跳的检测方法（挖坑） 测量相位只能得到周内的小数部分 (fraction)，所以整数部分是未知的，也是无法测量的 瞬时的测量能够得到小数部分，如果保持追踪，载波相位应该是连续变化的 注：我们把位置信息叫做解，把载波相位未知的整数部分叫做整周模糊度，把EKF中所有带估计量整体向量叫做状态量 通过EKF（或者最小二乘法）已经有了浮点模糊度 $\\hat{a}$，它们很遗憾不是整数，所以针对多个测量中的模糊度，要找一套整数组合 $\\check{a}$ ，这就是模糊度固定（一般把整数叫做fix） ","date":"2024-02-18","objectID":"/techBlog/posts/lambda/:1:1","tags":["RTKLIB"],"title":"LAMBDA算法","uri":"/techBlog/posts/lambda/"},{"categories":["GNSS"],"content":"变换到新空间以降相关 最优的整数组合 $\\breve{a}$ 应当满足目标函数最小的原则，目标函数还是残差平方和，设协方差矩阵为 $Q_{{\\hat{a}}}$ $$ \\breve a = argmin | (\\hat{a} - \\breve{a})^{T} Q_{\\hat{a}}^{-1} (\\hat{a} - \\breve{a}) $$ 这个公式可参考最小二乘法，其实就是残差平方和的矩阵形式 相关性就是协方差矩阵体现，应尽可能使得近似对角矩阵，这样相关性才低。通过Z变换来实现： $$ \\hat{z} = Z \\hat{a} \\ Q_{\\hat{z}} = Z Q_{\\hat a} Z^T \\ $$ 那如何找这个 $Z$: 要进行Choleskey分解：$Q_{\\hat{a}} = L D_{\\hat{a}} L^T \\quad Q_{\\hat{z}} = \\bar L D_{\\hat{z}} \\bar L^T$，其中 $L$ 是下三角矩阵且对角线上元素均为1，$D$ 是对角矩阵 LAMBDA算法要求：（为什么要这样也不清楚） $\\bar L$ 尽可能对角化（非对角元素小于0.5） $Q_{\\bar{a}}$​ 尽可能按序排列 所以后面会有降低和排序的操作 参考： ","date":"2024-02-18","objectID":"/techBlog/posts/lambda/:1:2","tags":["RTKLIB"],"title":"LAMBDA算法","uri":"/techBlog/posts/lambda/"},{"categories":["GNSS"],"content":"模糊度搜索 在新空间里面采取搜索算法（DFS等）找到最合适的解 较之原空间，搜索效率大大提高 ","date":"2024-02-18","objectID":"/techBlog/posts/lambda/:1:3","tags":["RTKLIB"],"title":"LAMBDA算法","uri":"/techBlog/posts/lambda/"},{"categories":["GNSS"],"content":"检验 就是比的残差平方和，次优解与最优解之比越大说明最优解这个最低值越突出，也说明越可靠 ","date":"2024-02-18","objectID":"/techBlog/posts/lambda/:1:4","tags":["RTKLIB"],"title":"LAMBDA算法","uri":"/techBlog/posts/lambda/"},{"categories":["GNSS"],"content":"RTKLIB源码 ","date":"2024-02-18","objectID":"/techBlog/posts/lambda/:2:0","tags":["RTKLIB"],"title":"LAMBDA算法","uri":"/techBlog/posts/lambda/"},{"categories":["GNSS"],"content":"Reference ","date":"2024-02-18","objectID":"/techBlog/posts/lambda/:3:0","tags":["RTKLIB"],"title":"LAMBDA算法","uri":"/techBlog/posts/lambda/"},{"categories":["Life"],"content":"家庭宽带所需基础知识 ","date":"2024-01-15","objectID":"/techBlog/posts/%E5%AE%BD%E5%B8%A6/:0:0","tags":["宽带"],"title":"宽带","uri":"/techBlog/posts/%E5%AE%BD%E5%B8%A6/"},{"categories":["Life"],"content":"1 名词解释 宽带：运营商提供的通讯资源 光猫：即光调制解调器(Modem)，运营商通过光纤将信号传入户，光猫负责将光信号转换为电信号 机顶盒：接收电信号将其转换为视频信号在电视上 电视一般有两个遥控器：一个是电视机本身的，另一个是信号源的，运营商提供的电视平台就是电视机接入的4K信号源 路由器：将信号转发，通过WIFI技术实现无线局域网WLAN，而光猫上也集成了无线转发功能，但性能远不如路由器 ","date":"2024-01-15","objectID":"/techBlog/posts/%E5%AE%BD%E5%B8%A6/:1:0","tags":["宽带"],"title":"宽带","uri":"/techBlog/posts/%E5%AE%BD%E5%B8%A6/"},{"categories":["Life"],"content":"2 示例 红色圈内的细白线就是光纤，接入光猫，调制为电信号，通过蓝色圈内的灰色粗线导出 从另一端，粗白线接入机顶盒，机顶盒将其转为视频信号，作为电视机的 4K HDMI1信号源 另一个头则可接入路由器，路由器进行无线转发 ","date":"2024-01-15","objectID":"/techBlog/posts/%E5%AE%BD%E5%B8%A6/:2:0","tags":["宽带"],"title":"宽带","uri":"/techBlog/posts/%E5%AE%BD%E5%B8%A6/"},{"categories":["theory","GNSS"],"content":"介绍RTK定位的浮点解怎么来的 ","date":"2023-12-13","objectID":"/techBlog/posts/rtk/:0:0","tags":["RTK"],"title":"RTK浮点解","uri":"/techBlog/posts/rtk/"},{"categories":["theory","GNSS"],"content":"非线性最小二乘 一个线性最小二乘方程的标准形式是： $$ Y = AX + V $$ $$A$$是设计矩阵，$$X$$是待估计参数，$$Y$$是测量量，$$V$$是残差，注意不要再带入直线拟合的符号标记 若带权（一般是方差倒数），解为： $$ \\hat{X} = (A^T R^{-1} A) ^{-1} A^T R^{-1} Y $$ 其中$$R^{-1}$$为权重矩阵 现在拓展到非线性最小二乘： ","date":"2023-12-13","objectID":"/techBlog/posts/rtk/:1:0","tags":["RTK"],"title":"RTK浮点解","uri":"/techBlog/posts/rtk/"},{"categories":["Tools"],"content":"基于前端作图的尝试 D3 D3.js是一个JavaScript库，它能够提供非常底层的绘图细节，这意味着高自定义度的同时也会很麻烦，平时极少需要这样，就当学习JavaScript了吧 和许多js库一样，都在html文件的head部分导入： \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eD3 Page Template\u003c/title\u003e \u003cscript type=\"text/javascript\" src=\"d3/d3.v7.js\"\u003e\u003c/script\u003e \u003c/style\u003e \u003c/head\u003e 这里的src是本地的js文件，也可以用网站的 d3.js和d3.min.js的区别在于d3.min.js去除了空格，没法阅读但是加载起来更快 在正文中使用d3对象的select方法 典型的例子是： d3.select(\"body\") .selectAll(\"div\") .data(dataset) .enter() .append(\"div\") .attr(\"class\", \"bar\") .style(\"height\", function(d){ return d*5 + \"px\"; }) 这里面有一些基础的js知识，我在这里不多讲，它们本来也跟d3没有关系 基本上d3就是在调用各种方法，而这些方法的返回都会是html对象的引用 var svg = d3.select(\"body\").append(\"svg\"); 这样就后面可以单独使用了 于是乎后面就是要重点讲这些方法 select selectAll 对于还未创建的对象，返回空（D3的特点就是要先选择将要操作的对象，再创建 data遍历传入数组，每个元素相当于一个子对象 enter 为每个子对象创建占位符 append添加html元素 attr设置属性 function的参数输入依次是：元素、下标 感觉其实使用上并不难理解，主要还是API太多了，这其实也是前端这行的特点，太多功能了 现在有了GPT相信应该不难 ","date":"2023-11-26","objectID":"/techBlog/posts/d3%E5%9F%BA%E7%A1%80/:0:0","tags":["D3.js","JavaScript","Web"],"title":"D3基础","uri":"/techBlog/posts/d3%E5%9F%BA%E7%A1%80/"},{"categories":["theory"],"content":"最小二乘法可谓是至关重要的数学工具 最小二乘法 ","date":"2023-11-23","objectID":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/:0:0","tags":["WLS","machine learning"],"title":"最小二乘法","uri":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"categories":["theory"],"content":"基本思想 在最简单的一元线性函数拟合问题中，可以很直观得到目标函数：残差平方和 $$\r\\begin{aligned}\r\\boldsymbol{\\hat{\\phi}}\u0026 =\\quad\\underset{\\boldsymbol{\\phi}}{\\operatorname*{argmin}}\\Big[\\operatorname{L}[\\phi]\\Big] \\\\\r\u0026=\\quad\\underset{\\boldsymbol{\\phi}}{\\operatorname*{argmin}}\\left[\\sum_{i=1}^{I}\\left(\\mathrm{f}[x_i,\\boldsymbol{\\phi}]-y_i\\right)^2\\right] \\\\\r\u0026=\\quad\\underset{\\phi}{\\operatorname*{argmin}}\\left[\\sum_{i=1}^I\\left(\\phi_0+\\phi_1x_i-y_i\\right)^2\\right].\r\\end{aligned}\r$$\r要使得该目标函数最小，方法是朝着梯度下降的方向行进，这在机器学习中很常用\r在数学上，最低点应该是一个极值点，对参数的偏导为0 $$ \\begin{aligned}\\frac{\\partial L}{\\partial\\phi_0}\u0026=2\\sum_1^n\\left(y_i-\\hat{\\phi_0}-\\hat{\\phi_1}x_i\\right)=0\\\\\\frac{\\partial L}{\\partial\\phi_1}\u0026=2\\sum_1^n\\left(y_i-\\hat{\\phi_0}-\\hat{\\phi_1}x_i\\right)=0\\end{aligned} $$ ","date":"2023-11-23","objectID":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/:1:0","tags":["WLS","machine learning"],"title":"最小二乘法","uri":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"categories":["theory"],"content":"矩阵表示 如果用矩阵表示多元线性函数： $$ h_\\phi(\\mathbf{x})=\\mathbf{X \\phi} \\ Y = \\mathbf{X \\phi} + V $$ 目标函数可定义为： $$ J(\\phi)=\\frac12(\\mathbf{X}\\phi-\\mathbf{Y})^T(\\mathbf{X}\\phi-\\mathbf{Y}) $$ 这里的二分之一是为了去掉下面求导的2 同样求偏导： $$ \\frac\\partial{\\partial\\phi}J(\\phi)=\\mathbf{X}^T(\\mathbf{X}\\phi-\\mathbf{Y})=0 \\ \\mathbf{X}^T\\mathbf{X}\\phi=\\mathbf{X}^T\\mathbf{Y} $$ 解这个矩阵方程，得到的$\\mathbf{\\hat{\\phi}}$ $$ \\mathbf{\\hat{\\phi}}=(\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{Y} $$ ","date":"2023-11-23","objectID":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/:2:0","tags":["WLS","machine learning"],"title":"最小二乘法","uri":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"categories":["theory"],"content":"加权 加权最小二乘，一般在不等精度测量中使用 加权加在最后残差不是简单平方和，而是加权平法和 这样的矩阵表示是： $$ J(\\phi)=\\frac12 (\\mathbf{X}\\phi-\\mathbf{Y})^T \\mathbf{P} (\\mathbf{X}\\phi-\\mathbf{Y}) $$ 解为： $$ \\mathbf{\\hat{\\phi}}=(\\mathbf{X}^T\\mathbf{P}\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{P}\\mathbf{Y} $$ 一般来说，这个权值不是随便定的，而是根据协方差矩阵来的 随机误差协方差矩阵： $$ \\mathrm{R}=\\mathrm{E}(\\mathrm{v}^\\mathrm{T})= \\begin{pmatrix} \\sigma_1^2 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 \\cdots \u0026 \\sigma_\\mathrm{k}^2 \\end{pmatrix} $$ 则权值即为协方差倒数：$P = R^{-1}$ $$ \\mathrm{J}=\\frac{\\varepsilon_1^2}{\\sigma_1^2}+\\frac{\\varepsilon_2^2}{\\sigma_2^2}+…+\\frac{\\varepsilon_k^2}{\\sigma_k^2}=\\varepsilon^T\\mathrm{R}^{-1}\\varepsilon $$ ","date":"2023-11-23","objectID":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/:3:0","tags":["WLS","machine learning"],"title":"最小二乘法","uri":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"categories":["theory"],"content":"非线性情况 对于非线性方程，也是想将其变为线性方程来求 ","date":"2023-11-23","objectID":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/:4:0","tags":["WLS","machine learning"],"title":"最小二乘法","uri":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"categories":["theory"],"content":"线性回归 回归的含义是指预测连续量，区别于分类问题 线性回归也就是指用线性函数预测，通过已有数据结合最小二乘法拟合出直线，这就是线性回归，在机器学习中这个过程就是训练 ","date":"2023-11-23","objectID":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/:5:0","tags":["WLS","machine learning"],"title":"最小二乘法","uri":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"categories":["theory"],"content":"概统角度 若测量误差服从高斯分布，只有随机噪声，那么认为测量量是无偏的： $$ E(Y) = X \\phi $$ 则有： $$ E(\\hat{\\phi}) = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{X} \\phi = \\phi $$ 所以也是无偏的，即极大似然估计 ","date":"2023-11-23","objectID":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/:6:0","tags":["WLS","machine learning"],"title":"最小二乘法","uri":"/techBlog/posts/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"categories":["Theory"],"content":"图像的基本知识：通道、分辨率等等 图像 严格来说这里讨论的是数字图像Digital Image ","date":"2023-11-20","objectID":"/techBlog/posts/%E5%9B%BE%E5%83%8F%E7%9F%A5%E8%AF%86/:0:0","tags":["Image"],"title":"图像基本知识","uri":"/techBlog/posts/%E5%9B%BE%E5%83%8F%E7%9F%A5%E8%AF%86/"},{"categories":["Theory"],"content":"像素、分辨率、尺寸 数字图像是一个矩阵，其中每个元素代表一个像素pixel 分辨率描述细节的丰富度，一般以DPI或PPI来表示 DPI, dots-per-inch：打印时，每英寸（长宽）油墨点数 PPI, pixels-per-inch: 显示时，每英寸（对角线）像素数量 注意英寸inch这个概念，一般屏幕的尺寸中的寸指的是对角线的长度，这需要知道长宽比才能知道屏幕到底多大，而照片中所说的寸照指得是一条边的长度，这种长宽比一般是固定的，平时交流没有很严格 一张数字图片的尺寸size or pixel dimesnsions，都不是物理尺寸，而是长宽的像素个数 ","date":"2023-11-20","objectID":"/techBlog/posts/%E5%9B%BE%E5%83%8F%E7%9F%A5%E8%AF%86/:1:0","tags":["Image"],"title":"图像基本知识","uri":"/techBlog/posts/%E5%9B%BE%E5%83%8F%E7%9F%A5%E8%AF%86/"},{"categories":["Theory"],"content":"720p, 1080p, 4K 在视频格式中，p指的是逐行扫描，1080p指的是有1080条水平扫描线，对应的分辨率是1920x1080，都是16:9 而4K则表示的是水平像素有约4k个 ","date":"2023-11-20","objectID":"/techBlog/posts/%E5%9B%BE%E5%83%8F%E7%9F%A5%E8%AF%86/:1:1","tags":["Image"],"title":"图像基本知识","uri":"/techBlog/posts/%E5%9B%BE%E5%83%8F%E7%9F%A5%E8%AF%86/"},{"categories":["Theory"],"content":"通道、深度 颜色由 R G B三原色组成，即三个通道，三种颜色以不同强度混合成各种各样的颜色 用来存储值的比特位数即为深度 逻辑上应该是三维矩阵，实际上一般是用的24bit，每8个bit表示一个RBG通道，这样每个通道取值是0-255，从最暗（黑）到最亮（白），位数越多能表示的颜色就越丰富 ","date":"2023-11-20","objectID":"/techBlog/posts/%E5%9B%BE%E5%83%8F%E7%9F%A5%E8%AF%86/:2:0","tags":["Image"],"title":"图像基本知识","uri":"/techBlog/posts/%E5%9B%BE%E5%83%8F%E7%9F%A5%E8%AF%86/"},{"categories":["Theory"],"content":"透明度与Alpha通道 RGBA图像多一个Alpha通道，用来告诉计算机不透明信息 这其实是用来混合图像用的，对于单幅图像来说，不透明度其实没有意义 设图片A：$(R_A, G_A, B_A, \\alpha_A)$，和背景B：$(R_B,G_B,B_B,\\alpha_B)$ 那么实际显示的图像是C：$(R_A*\\alpha_A + R_B*\\alpha_B, G_A*\\alpha_A + G_B*\\alpha_B, B_A*\\alpha_A + B_B*\\alpha_B)$ ","date":"2023-11-20","objectID":"/techBlog/posts/%E5%9B%BE%E5%83%8F%E7%9F%A5%E8%AF%86/:2:1","tags":["Image"],"title":"图像基本知识","uri":"/techBlog/posts/%E5%9B%BE%E5%83%8F%E7%9F%A5%E8%AF%86/"},{"categories":["theory","GNSS"],"content":"结合理论和在RTKLIB中的具体算法学习RTK定位 ","date":"2023-11-14","objectID":"/techBlog/posts/rtklib/:0:0","tags":["RTKLIB","RTK"],"title":"RTKLIB","uri":"/techBlog/posts/rtklib/"},{"categories":["theory","GNSS"],"content":"RTK 先要清楚： RTK指的是【实时动态载波相位差分定位】，但RTKLIB能做的远远不是纯RTK RTKLIB是先用卡尔曼滤波获得浮点解再确定整周模糊度，至于在纯理论层面到底RTK是咋个算的也没有定论，这个东西就是没有统一算法，RTK这个可能代表的只是一种思想而非具体的算法 符号标记以RTKLIB manual中的符号为准，也会提到其它的写法 总的来说，是先通过单点定位结果作为初值（$x_{k-1}(+)$），然后带入卡尔曼状态方程预测下一个历元的状态（$x_k(-)$），又根据基站位置、单点定位结果计算卫地距 -\u003e 非差残差 -\u003e 双差残差，根据双差残差确定卡尔曼状态更新方程中的增益矩阵$H_k$等等参数，然后更新状态 （$x_k(+)$），这个状态就是包含了浮点解，然后再通过LAMBDA算法固定得到固定解 对于RTKLIB来说多了很多校正、验证环节，这些在纯理论上往往没有提到，若考虑这些又会增加很多内容，因而看起来很困难 我们先简易版看一下： ","date":"2023-11-14","objectID":"/techBlog/posts/rtklib/:1:0","tags":["RTKLIB","RTK"],"title":"RTKLIB","uri":"/techBlog/posts/rtklib/"},{"categories":["theory","GNSS"],"content":"浮点解 浮点解指的是整周模糊度尚未固定的解，这样算出来的解到底为什么“对”其实我也不理解 ","date":"2023-11-14","objectID":"/techBlog/posts/rtklib/:2:0","tags":["RTKLIB","RTK"],"title":"RTKLIB","uri":"/techBlog/posts/rtklib/"},{"categories":["theory","GNSS"],"content":"符号 在Kalman滤波中这里用到两个方程，我愿称之为状态预测方程和状态更新方程，在RTKLIB Manual中用 $-,+$分别表示更新前和后，而一般在论文中用的是专业的数学符号，状态量 $\\tilde{x}$，估计量$\\hat{x}$ 该状态被定义为： $$ x=({r_r}^T,{v_r}^T,{B_1}^T,{B_2}^T,{B_5}^T)^T $$ 包含位置向量、速度向量、单差整周模糊度 状态预测方程： $$ \\begin{aligned}\\tilde{x}k\u0026=F{k,k-1}\\hat{x}{k-1}+w_k\\\\tilde{P}k\u0026=F{k,k-1}\\hat{P}{k-1}F_{k,k-1}^T+Q_k\\end{aligned} $$ 状态更新方程： $$ \\begin{gathered}K_k=\\tilde{P}_kH_k^T(H_k\\tilde{P}_kH_k^T+R_k)^{-1} \\ \\hat{x}_k=\\tilde{x}_k+K_k(y_k-H_k\\tilde{x}_k)\\\\hat{P}_k=(I-K_kH_k)\\tilde{P}_k\\end{gathered} $$ ","date":"2023-11-14","objectID":"/techBlog/posts/rtklib/:2:1","tags":["RTKLIB","RTK"],"title":"RTKLIB","uri":"/techBlog/posts/rtklib/"},{"categories":["theory","GNSS"],"content":"初始值 很重要的一点是，在RTKLIB中，会先用SPP定位结果作为初值去得到待状态，此外在后面的移动站非差残差计算中也用到SPP定位结果来算卫地距 SPP计算出移动站位置、速度，通过下面方程得到单差整周模糊度： $$ B_{rb} = P_{rb} / \\lambda - \\varphi_{rb} $$ 这些作为初值建立状态量 $x$ 用SPP结果作为 $\\hat{x}{k-1}$ 带入状态预测方程中，得到状态 $\\tilde{x}{k} $ ","date":"2023-11-14","objectID":"/techBlog/posts/rtklib/:2:2","tags":["RTKLIB","RTK"],"title":"RTKLIB","uri":"/techBlog/posts/rtklib/"},{"categories":["theory","GNSS"],"content":"非差残差 基准站 如果已知位置则可以直接用，没有则用基准站的观测文件同样计算SPP结果作为基准站坐标 根据星历参数计算出卫星的坐标 计算卫地距 $\\rho$ （注意伪距观测量$P$和协方差矩阵$P$的区别） 修正：钟差、对流层、天线 非差残差 = 观测值 - 修正后的卫地距 设基准站$b$在$k$历元关于卫星$s$的非差残差为$y_{b,k}^{s}$，则载波相位上的残差为： $$ y_{b,k}^{s} = \\lambda ~\\phi_{b,k}^s - (\\rho_{b,k}^s - dist(clk_{b,k}^s) + dist(trop_{b,k}^s) + dist(ant_{b,k}^s)) $$ 后面为了简洁就统一为距离量了，这在这行挺常见的 移动站 使用SPP定位结果计算卫地距，流程和基准站一样 ","date":"2023-11-14","objectID":"/techBlog/posts/rtklib/:2:3","tags":["RTKLIB","RTK"],"title":"RTKLIB","uri":"/techBlog/posts/rtklib/"},{"categories":["theory","GNSS"],"content":"双差残差 ","date":"2023-11-14","objectID":"/techBlog/posts/rtklib/:2:4","tags":["RTKLIB","RTK"],"title":"RTKLIB","uri":"/techBlog/posts/rtklib/"},{"categories":["theory","GNSS"],"content":"固定解 ","date":"2023-11-14","objectID":"/techBlog/posts/rtklib/:3:0","tags":["RTKLIB","RTK"],"title":"RTKLIB","uri":"/techBlog/posts/rtklib/"},{"categories":["theory","GNSS"],"content":"单差模糊度 单差模糊度转双差模糊度，建立最小二乘问题 降相关：变换到新的空间 分解单差模糊度的协方差矩阵，得到对角化矩阵 $D$，然后核验，得到 $z$ 模糊度搜索：在新空间新方程找到最优解，再逆变换回来 ","date":"2023-11-14","objectID":"/techBlog/posts/rtklib/:3:1","tags":["RTKLIB","RTK"],"title":"RTKLIB","uri":"/techBlog/posts/rtklib/"},{"categories":["coding"],"content":"从自己遇到的大工程出发，理解多文件的c/c++工程是怎么工作的 C/C++ 编译构建 ","date":"2023-11-05","objectID":"/techBlog/posts/%E7%BC%96%E8%AF%91/:0:0","tags":["条件编译#if"],"title":"C/C++ 编译构建","uri":"/techBlog/posts/%E7%BC%96%E8%AF%91/"},{"categories":["coding"],"content":"#define与#ifdef等 宏(MARCO)，代表批量处理 #define是进行宏替换，在预处理阶段直接进行文本替换 所以最常用的是通过这个表示一个常量，也可以用其替换一个函数等等，总之是文本的替换，相当于它帮你进行了 查找-替换 预处理阶段还能有选择性地保留某部分代码进行编译 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(){ #ifdef _DEBUG printf(\"正在使用 Debug 模式编译程序...\\n\"); #else printf(\"正在使用 Release 模式编译程序...\\n\"); #endif system(\"pause\"); return 0; } 这里就是如果有定义_DEBUG，则保留第一个printf，而第二个printf不进行编译 在VS当中的 属性::C/C++::预处理器::预处理器定义中便是在定义宏 这在跨平台开发、debug和release的区别毕竟常见 #if是根据常量表达式，#ifdef是看宏是否有被定义过 #define和#ifdef配合使用，就启动了不同options下不同版本的编程效果 make与cmake make是一个批处理工具，相当于执行脚本 通过makefile中的命令进行编译 而cmake可以自动生成makefile，它更具CMakeList.txt中的配置 ","date":"2023-11-05","objectID":"/techBlog/posts/%E7%BC%96%E8%AF%91/:1:0","tags":["条件编译#if"],"title":"C/C++ 编译构建","uri":"/techBlog/posts/%E7%BC%96%E8%AF%91/"},{"categories":["Tools"],"content":"从配置中得到的启示 VSCode配置理解 本身是一个编辑器，并不是如VS那样的IDE 但可以配置插件（脚本）实现类似的效果，对于轻量开发十分好用 ","date":"2023-10-30","objectID":"/techBlog/posts/vscode/:0:0","tags":["VSCode"],"title":"VSCode配置理解","uri":"/techBlog/posts/vscode/"},{"categories":["Tools"],"content":"逻辑 对于c/c++，要经过编译链接形成成.o或.exe，使用编译器来做这个事情也是需要输入参数、选项，现在用VSC来帮我们做这件事情，tasks.json就是构建build的指示说明 VSC中的c/c++，并没有原生的运行，在这里面都是视为调试，都需要gdb 而插件Code Runner才算是在纯粹运行： \"cpp\": \"cd $dir \u0026\u0026 g++ $fileName -o $fileNameWithoutExt \u0026\u0026 $dir$fileNameWithoutExt\", \"c\": \"cd $dir \u0026\u0026 gcc $fileName -o $fileNameWithoutExt \u0026\u0026 $dir$fileNameWithoutExt\", \"python\": \"python -u\", 看VSC是怎么run c/c++ file的： Executing task: C/C++: g++.exe build active file Starting build...\rG:/mingw/msys64/ucrt64/bin/g++.exe -fdiagnostics-color=always -g G:\\geek\\vsc\\hello.cpp -o G:\\geek\\vsc\\exe\\hello.exe #这是正常的编译生成\rBuild finished successfully.\rTerminal will be reused by tasks, press any key to close it. #这时启动了cppdbg终端 G:\\geek\\vsc\u003e cmd /C \"c:\\Users\\zvict\\.vscode\\extensions\\ms-vscode.cpptools-1.17.5-win32-x64\\debugAdapters\\bin\\WindowsDebugLauncher.exe --stdin=Microsoft-MIEngine-In-3cgnpwjs.irb --stdout=Microsoft-MIEngine-Out-krfimryw.n30 --stderr=Microsoft-MIEngine-Error-4y053itd.pmt --pid=Microsoft-MIEngine-Pid-k0bhgb4z.hh4 --dbgExe=G:\\mingw\\msys64\\ucrt64\\bin\\gdb.exe --interpreter=mi \"\rHello C++ World from VS Code and the C++ extension! #这是结果 可见是启动了内置的cpptools的调试启动器，启动的是指定的gdb 所以它所谓运行其实还是调试，是忽略断点的调试而已 在VSC，launch是一个重要概念，它指示如何使用调试器来调试，可以编写launch.json文件自定义，但实际上它应该是setting.json中的一部分 一般是不需要配置的其实，除非有必要的参数输入 最后的c_cpp_properties.json则是告诉编译器位置、C++标准、IntelliSense设定等信息的配置 先执行Task，再Launch Debugger，在launch中需指定preLaunchTask与tasks中的label名一致 ","date":"2023-10-30","objectID":"/techBlog/posts/vscode/:1:0","tags":["VSCode"],"title":"VSCode配置理解","uri":"/techBlog/posts/vscode/"},{"categories":["Tools"],"content":"MinGW vs MSVC 可以这样理解： GNU计划(GNU’s Not Unix)，希望开发类UNIX操作系统，开发了许多组件，但没有开发出内核 后来Linux内核被开发出来，与GNU组件结合，称之为GNU/Linux操作系统，现在一般就称之为Linux操作系统 GNU中有很多熟悉的组件：GCC, Bash … 编译器组件GCC，对于Windows，GNU这边有一个Windows支持版：MinGW，而微软自家也有自己的工具：VC VSCode市面上主要是用的MinGW ","date":"2023-10-30","objectID":"/techBlog/posts/vscode/:2:0","tags":["VSCode"],"title":"VSCode配置理解","uri":"/techBlog/posts/vscode/"},{"categories":["Tools"],"content":"MSVC配置 太麻烦了，需要从开发者启动 ","date":"2023-10-30","objectID":"/techBlog/posts/vscode/:2:1","tags":["VSCode"],"title":"VSCode配置理解","uri":"/techBlog/posts/vscode/"},{"categories":["Tools"],"content":"MinGW配置 C/C++ Extension IntelliSense会有 安装MinGW并添加至环境变量 查看： $ gcc -v\rgcc version 8.1.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 按VScode官方安装吧 首次选择会成为默认tasks 运行后卡住没反应（无解，只能重新安装mingw再来一次了 可见其实还是要信official的 ","date":"2023-10-30","objectID":"/techBlog/posts/vscode/:2:2","tags":["VSCode"],"title":"VSCode配置理解","uri":"/techBlog/posts/vscode/"},{"categories":["Development"],"content":"安装双系统、扩容、迁移的稀里糊涂成功经验 Win+Ubuntu双系统那些事 ","date":"2023-10-24","objectID":"/techBlog/posts/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E6%89%A9%E5%AE%B9/:0:0","tags":["Ubuntu"],"title":"Win+Ubuntu双系统那些事","uri":"/techBlog/posts/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E6%89%A9%E5%AE%B9/"},{"categories":["Development"],"content":"安装Ubuntu作为第二系统 ","date":"2023-10-24","objectID":"/techBlog/posts/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E6%89%A9%E5%AE%B9/:1:0","tags":["Ubuntu"],"title":"Win+Ubuntu双系统那些事","uri":"/techBlog/posts/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E6%89%A9%E5%AE%B9/"},{"categories":["Development"],"content":"step 1: 准备 需要让PC的BIOS/UEFI去安装一个系统，就需要一个启动盘，一般用的是U盘，用专业的烧录工具将镜像写入U盘即可 官方推荐：Rufus - 轻松创建 USB 启动盘 镜像下载：官网即可，如果速度太慢则可以去镜像源（如清华大学开源软件镜像站）下载 什么是BIOS和UEFI？ BIOS是计算机上电后在执行的基本程序，计算机组成原理中都会讲到；到了现代UEFI将逐渐取代BIOS，UEFI功能更加丰富，支持文件系统，也就能做更多的事情 不过在这个领域BIOS不一定就是这里所指的BIOS，就像ARM在不同语境有不同的含义 对于电脑来说，常说“进入BIOS设置”，这里的BIOS到底是什么也不好说，算是厂商提供给我们的一种选择启动方式的入口 ","date":"2023-10-24","objectID":"/techBlog/posts/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E6%89%A9%E5%AE%B9/:1:1","tags":["Ubuntu"],"title":"Win+Ubuntu双系统那些事","uri":"/techBlog/posts/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E6%89%A9%E5%AE%B9/"},{"categories":["Development"],"content":"加装新硬盘扩容 没找到可以直接分配的办法，只能是把原来的ubuntu系统迁移到新硬盘上面 新硬盘创建分区（Gparted） dd命令移动 更新分区信息 grub修复（无需更新uuid和移动boot） 看起来似乎是创建了两个同样的入口，启动顺序问题也变了 应该用推荐修复，这就只有一个了，grub一修复就需要重新配置默认启动了 ","date":"2023-10-24","objectID":"/techBlog/posts/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E6%89%A9%E5%AE%B9/:2:0","tags":["Ubuntu"],"title":"Win+Ubuntu双系统那些事","uri":"/techBlog/posts/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E6%89%A9%E5%AE%B9/"},{"categories":["Development"],"content":"关于ROS需要知道的事情 ROS1基础 Robot Operating System，是一个软件框架，用以创建和管理机器人应用程序的，并不完全是潜意识里的控制机器人行为的代理 The Robot Operating System (ROS) is a set of software libraries and tools that help you build robot applications 在ROS中，不同的软件组件叫做节点Node，相当于一个进程，可以通过主题topics和服务services两种不同的方式进行通信，模块化编程 它采用自己的构建工具：ROS1catkin ROS2colcon 本质上也属于OS，因此很多概念带入操作系统的思维去理解比较好 ","date":"2023-10-18","objectID":"/techBlog/posts/ros%E5%9F%BA%E7%A1%80/:0:0","tags":["platform","ROS"],"title":"ROS基础知识","uri":"/techBlog/posts/ros%E5%9F%BA%E7%A1%80/"},{"categories":["Development"],"content":"ROS1发行版 主要就是这三个：ROS Kinetic、ROS Melodic和ROS Noetic ","date":"2023-10-18","objectID":"/techBlog/posts/ros%E5%9F%BA%E7%A1%80/:1:0","tags":["platform","ROS"],"title":"ROS基础知识","uri":"/techBlog/posts/ros%E5%9F%BA%E7%A1%80/"},{"categories":["Development"],"content":"基本概念 ROS采用点对点网络，称之为计算图 基本概念包括：nodes, Master, Parameter Server, messages, services, topics, and bags 这些数据结构在ros_comm库里面实现 节点Nodes: 执行计算处理的基本执行单元，可以理解为一个进程 主机Master：信息中心，充当服务器，管理节点通信 参数服务器：存储和共享节点的参数、配置信息 消息：节点传递数据的标准格式（可以理解为报文吧） 服务：节点之间请求-响应的通信方式 话题：节点之间发布-订阅，实现异步通信的方式 数据包：存档？ ","date":"2023-10-18","objectID":"/techBlog/posts/ros%E5%9F%BA%E7%A1%80/:2:0","tags":["platform","ROS"],"title":"ROS基础知识","uri":"/techBlog/posts/ros%E5%9F%BA%E7%A1%80/"},{"categories":["Development"],"content":"RVIZ rviz是ROS的一个三维可视化工具 ","date":"2023-10-18","objectID":"/techBlog/posts/ros%E5%9F%BA%E7%A1%80/:3:0","tags":["platform","ROS"],"title":"ROS基础知识","uri":"/techBlog/posts/ros%E5%9F%BA%E7%A1%80/"},{"categories":["Development"],"content":"launch文件 定义启动配置的xml文件，按照这上面的说明进行启动，只是描述语言并不是脚本 ","date":"2023-10-18","objectID":"/techBlog/posts/ros%E5%9F%BA%E7%A1%80/:4:0","tags":["platform","ROS"],"title":"ROS基础知识","uri":"/techBlog/posts/ros%E5%9F%BA%E7%A1%80/"},{"categories":["Tools"],"content":"基于typora+picgo-core，实现自动上传至github picgo图床配置 一般建议采用picgo-core，而不是picgo客户端，个人在windows平台使用时极容易卡死使得上传不成功 ","date":"2023-10-12","objectID":"/techBlog/posts/picgo/:0:0","tags":["markdown"],"title":"picgo图床配置","uri":"/techBlog/posts/picgo/"},{"categories":["Tools"],"content":"安装picgo core 两种办法 【方法一】： 在typora里面安装，这种最方便 【方法二】： 通过nodejs+npm方式安装，这种要麻烦一点，而且在ubuntu中安装时二者版本还不匹配，还特别难以匹配，但好处是这样安装的picgo是系统知道的，即可以使用picgo xxx命令 ","date":"2023-10-12","objectID":"/techBlog/posts/picgo/:1:0","tags":["markdown"],"title":"picgo图床配置","uri":"/techBlog/posts/picgo/"},{"categories":["Tools"],"content":"安装插件 至少需要安装一个github uploader，一般用githubPlus，其它平台也有类似插件 如果需要自动重命名（因为同名文件上传会冲突导致失败），还需要安装rename-file插件 如果是按【方法二】安装的picgo，则可以使用命令： picgo install github-plus picgo install rename-file 如果是【方法一】，则需要指定picgo的位置，可以通过typora中的验证图片上传选项看它用的命令找到picgo.exe(windows)或picgo(linux)的位置，替代上述中的picgo 例如：C:\\Users\\[yourname]\\AppData\\Roaming\\Typora\\picgo\\win64\\picgo.exe install xxx ","date":"2023-10-12","objectID":"/techBlog/posts/picgo/:2:0","tags":["markdown"],"title":"picgo图床配置","uri":"/techBlog/posts/picgo/"},{"categories":["Tools"],"content":"修改配置文件 无论那种方法安装，配置文件都是同一个，在windows中一般是C:\\Users\\zvict\\.picgo\\config.json，在linux中一般是~/.picgo/config.json 这里提供一个模板 { \"picBed\": { \"uploader\": \"githubPlus\", \"current\": \"githubPlus\", \"githubPlus\": { \"repo\": \"用户名/仓库名\", \"branch\": \"分支名\", \"token\": \"从github仓库中获得token\", \"path\": \"img/\", \"customUrl\": \"https://cdn.jsdelivr.net/gh/用户名/仓库名@分支名\", \"origin\": \"github\" }, \"transformer\": \"path\" }, \"picgoPlugins\": { \"picgo-plugin-github-plus\": true, \"picgo-plugin-rename-file\": true }, \"picgo-plugin-github-plus\": { \"lastSync\": \"2023-10-12 02:32:32\" }, \"picgo-plugin-rename-file\": { \"format\": \"{y}/{m}/{d}/{hash}-{origin}-{rand:6}\" } } jsdelivr是国内加速平台 ","date":"2023-10-12","objectID":"/techBlog/posts/picgo/:3:0","tags":["markdown"],"title":"picgo图床配置","uri":"/techBlog/posts/picgo/"},{"categories":["Tools"],"content":"运行 typora上传的本质也是执行picgo u filepath/name命令（u可换成upload） 点击验证图片上传选项会上传两张样例图片，看是否成功 如果不成功看报错是什么 个人遇到的问题： 找不到uploader：重启、重装githubplus可解决 invalid request：可以不用管，直接在编辑器粘贴上传即可 也可脱离typora，自己执行这个命令也可以，在typora自定义执行命令也可以改成picgo -u同样的效果，在obsidian中也是执行的这个命令 ","date":"2023-10-12","objectID":"/techBlog/posts/picgo/:4:0","tags":["markdown"],"title":"picgo图床配置","uri":"/techBlog/posts/picgo/"},{"categories":["Development"],"content":"NI DAQ以及相关软件 ","date":"2023-10-04","objectID":"/techBlog/posts/ni_daq/:0:0","tags":["NI"],"title":"NI DAQ使用教程","uri":"/techBlog/posts/ni_daq/"},{"categories":["Development"],"content":"NI系列工具 现在的NI换了新logo，各方面也更现代化 NI现在使用Manager的思想，有Package Manager、Liscense Manager、启动器等，管理所有NI产品 破解也是一个工具可以破解全部：NI Liscense Activator 有一些软件是收费的（如Labview)，无法在Manager上搜到，在官网上也无法直接下载 可以直接下载的软件可以以online通过Manager安装，也可offline安装，通常可以选择安装路径，不过若是此前安装过NI产品在一个路径，后续安装是能识别的，在Manager中的安装也几乎是都放在这个目录下（尽管不能选） ","date":"2023-10-04","objectID":"/techBlog/posts/ni_daq/:1:0","tags":["NI"],"title":"NI DAQ使用教程","uri":"/techBlog/posts/ni_daq/"},{"categories":["Development"],"content":"DAQ软件依赖 DAQ是一个数据采集器，一般需要ELVIS Driver，安装它一般也会顺带安装了DAQmx 在MAX里面可以管理硬件设备，ELVIS还可以提供虚拟仪器 Express VI 在labview中使用DAQ助手 。。。。 安装顺序：labview -\u003e ELVIS 要想在labview中使用DAQ，需要与版本兼容的DAQmx，新版labview不完全兼容旧版的DAQmx DAQ code generation在2023Q1中还有问题，得安装2021 SP1才能用，那我何必呢，干嘛不直接使用2021 SP1呢（好吧2021没有conda virtual env 安装ELVIS时要选一些东西 ","date":"2023-10-04","objectID":"/techBlog/posts/ni_daq/:2:0","tags":["NI"],"title":"NI DAQ使用教程","uri":"/techBlog/posts/ni_daq/"},{"categories":["coding"],"content":"Javascript编程 ","date":"2023-07-24","objectID":"/techBlog/posts/javascript/:0:0","tags":["前端","html+js+css"],"title":"Javascript编程","uri":"/techBlog/posts/javascript/"},{"categories":["coding"],"content":"HTML+Javascript+CSS HTML是一种文本标记语言，是对文档结构的描述，浏览器根据这个来呈现界面 为了更丰富的动态交互功能，需要Javascript脚本来配合 用的最多的就是点击按钮然后怎么怎么样 CSS则是对图形的美化 前端编程都离不开浏览器 ","date":"2023-07-24","objectID":"/techBlog/posts/javascript/:1:0","tags":["前端","html+js+css"],"title":"Javascript编程","uri":"/techBlog/posts/javascript/"},{"categories":["coding"],"content":"HTML中使用Javascript 两种方式：脚本写在文件内或是引用外部.js文件 javascript作为html中一个\u003cscript\u003e块来被浏览器理解 ","date":"2023-07-24","objectID":"/techBlog/posts/javascript/:2:0","tags":["前端","html+js+css"],"title":"Javascript编程","uri":"/techBlog/posts/javascript/"},{"categories":["Computer System"],"content":"随缘更，这本神书真的不知道猴年马月才能看懂看完，看的还是英文版 Computer System: A Programmer’s Perspective 预处理阶段是将#include的这些文件直接作为文本插入到源文件当中 所有不同的语言、不同的编译器都是变成同样的汇编语言形式（当然了，肯定跟什么计算机有关） 链接的printf.o是由编译器提供的，而不是一个#include 了解一点编译器和硬件的知识有助于选择合适的方法实现最大性能 ","date":"2023-07-21","objectID":"/techBlog/posts/csapp/:0:0","tags":["System"],"title":"CSAPP","uri":"/techBlog/posts/csapp/"},{"categories":["AI"],"content":"base on 《Deep Learning with Python》(Python深度学习) by Francois Chollet Machine Learning 机器学习思想和传统编程的区别： 根据数据的答案发现统计规律，这个过程叫做training，而传统的是programming，即遵循程序员写定的rules完成输入到输出 但是，这种统计规律是传统数量统计难以分析的，它并非像是一门数学，而是一种工程经验，实践结果永远大于理论推导 根据一个指标衡量现在的输出和理想输出的距离，用它来自我调整，这个过程就是learning 机器学习是在对数据进行有意义地变换，因此需要找到一种有力的数据的表示representation方法 即经过坐标变换后的数据的新的表示，能够更容易的进行分类任务 机器学习则是自动搜索有用的表示方法，并用评价指标作为反馈进行调整，使之能够用简单的规则完成任务 搜索预定义的一组操作，即假设空间hypothesis space searching for useful representations and rules over some input data, within a predefined space of possibilities, using guidance from a feedback signal. 在预先定义好的可能性空间中，利用反馈信号的指引来寻找输入数据的有用表示 ","date":"2023-07-21","objectID":"/techBlog/posts/deep-learning/:0:0","tags":["Machine Learning","Deep Learning"],"title":"机器学习/深度学习入门","uri":"/techBlog/posts/deep-learning/"},{"categories":["AI"],"content":"Deep Learning deep指的是连续的表示层，即深度学习代表了一种“分层表示”的思想 深度学习一般包括数十个甚至上百个层，而其它机器学习方法通常只有一两层，叫做浅层学习 一般是通过神经网络模型来学习得到这些分层的 a multistage way to learn data representations 学习数据表示的多级方法 一个层对输入的操作体现在其权重上面，权重就是这个层的参数，神经网络就是寻找合适的参数 评价指标是loss fuction，通过loss衡量与理想结果的距离作为反馈进行调整，把这个调整操作看做一个优化器来做的 而优化器做的调整，就是梯度下降算法，是这个让神经网络有了强大的生命力，这种算法的来由另一篇帖子就讲过了 ","date":"2023-07-21","objectID":"/techBlog/posts/deep-learning/:1:0","tags":["Machine Learning","Deep Learning"],"title":"机器学习/深度学习入门","uri":"/techBlog/posts/deep-learning/"},{"categories":["AI"],"content":"其它机器学习算法 机器学习不只有深度学习这一种，还有很多其它的模型 ","date":"2023-07-21","objectID":"/techBlog/posts/deep-learning/:2:0","tags":["Machine Learning","Deep Learning"],"title":"机器学习/深度学习入门","uri":"/techBlog/posts/deep-learning/"},{"categories":["AI"],"content":"base on 《Make Your Own Neural Network》by Tariq Rashid, 中文版 神经网络 ","date":"2023-07-17","objectID":"/techBlog/posts/neural_network/:0:0","tags":["神经网络"],"title":"神经网络入门-MINIST（未完待续）","uri":"/techBlog/posts/neural_network/"},{"categories":["AI"],"content":"理论 ","date":"2023-07-17","objectID":"/techBlog/posts/neural_network/:1:0","tags":["神经网络"],"title":"神经网络入门-MINIST（未完待续）","uri":"/techBlog/posts/neural_network/"},{"categories":["AI"],"content":"结构 神经元不会理解做出反应，而是会抑制输出，直到输入大到超过阈值才触发输出（避免噪声） 所以有激活函数，直观来讲输入输出是一个阶跃函数，但一般改进为S函数：平滑更符合自然规律 多个输入信号被组合成更强大的输入信号 神经元输出传递也是后面神经元的输入： 于是我们对它进行分层设计： 现在需要进行学习调整其中的参数，其中最简单的方法就是各个边的权重 一开始权重取随机值 ","date":"2023-07-17","objectID":"/techBlog/posts/neural_network/:1:1","tags":["神经网络"],"title":"神经网络入门-MINIST（未完待续）","uri":"/techBlog/posts/neural_network/"},{"categories":["AI"],"content":"输出 第一层仅接受输入 这个计算输出可以用矩阵来简化 $$\rX = WI \\\\\rO = sigmoid(I)\r$$\r对于三层网络，一般称中间那层为隐藏层\r输入层-隐藏层，隐藏层-输出层之间都有这个关系 ","date":"2023-07-17","objectID":"/techBlog/posts/neural_network/:1:2","tags":["神经网络"],"title":"神经网络入门-MINIST（未完待续）","uri":"/techBlog/posts/neural_network/"},{"categories":["AI"],"content":"反向传播 将样本的结果和计算结果比较得到误差 将误差分给多个输入优化它们的权重 这就是反向传播： 相当于翻过来输出当输入，得到每个节点的误差值（尽管中间节点并没有一个目标值） ","date":"2023-07-17","objectID":"/techBlog/posts/neural_network/:1:3","tags":["神经网络"],"title":"神经网络入门-MINIST（未完待续）","uri":"/techBlog/posts/neural_network/"},{"categories":["AI"],"content":"权重更新：梯度下降法 找到总误差的最小值点，这里定义总误差为： $$ E = e_1^2 + e_2^2 +…+e_n^2 $$ 这样避免了相互抵消 以梯度下降的方向更新权重，需要求出梯度、选择合适的步长，步长的选择影响还是很大的： 步长以学习率$\\alpha$来反应： $$ w_{j,k} = w_{j,k} - \\alpha\\frac{\\partial E}{\\partial w_{j,k}} $$ 现在只考虑隐藏层和输出层之间的权重： $$\rE = \\sum (t_k -o_k)^2 \\\\\r\\frac{\\partial E}{\\partial w_{j,k}} = \\frac{\\partial E}{\\partial o_k} \\cdot \\frac{\\partial o_k}{\\partial w_{j,k}}\r$$\r$t_k$是目标值是常数，进一步化简，得到表达式：\r这是隐藏层与输出层之间的权重，而输入层与隐藏层之间的权重，通过节点的“误差”代换掉即可，这里用到了对称性的思想 总之，我们统一为： ","date":"2023-07-17","objectID":"/techBlog/posts/neural_network/:1:4","tags":["神经网络"],"title":"神经网络入门-MINIST（未完待续）","uri":"/techBlog/posts/neural_network/"},{"categories":["AI"],"content":"实践 训练集：用于训练 测试集：评价好坏 输出中最大的那个的编号作为结果 最理想的输出是 [0, 0, …1, 0, 0]这样的，但实际不可能(sigmoid)上下界 ","date":"2023-07-17","objectID":"/techBlog/posts/neural_network/:2:0","tags":["神经网络"],"title":"神经网络入门-MINIST（未完待续）","uri":"/techBlog/posts/neural_network/"},{"categories":["AI"],"content":"改进 多次重复训练叫做世代 epoch和学习率会影响性能： 网络的结构（隐藏层数量、层数） ","date":"2023-07-17","objectID":"/techBlog/posts/neural_network/:3:0","tags":["神经网络"],"title":"神经网络入门-MINIST（未完待续）","uri":"/techBlog/posts/neural_network/"},{"categories":["AI"],"content":"其它 自己的手写数字 反向查询：从label反推Image 对图像旋转后对结果的影响 源码： # build a class import numpy import scipy.special class neuralNetwork: # initial parameters and something else def __init__(self, inputnodes, hiddennodes, outputnodes, learningRate) -\u003e None: # the 3 layers self.inodes = inputnodes self.hnodes = hiddennodes self.onodes = outputnodes # learning rate alpha self.lr = learningRate # weight 正态分布 # self.wih = numpy.random.rand(self.hnodes, self.inodes) - 0.5 # self.who = numpy.random.rand(self.onodes, self.hnodes) - 0.5 self.wih = numpy.random.normal(0.0, pow(self.hnodes, -0.5), (self.hnodes, self.inodes)) self.who = numpy.random.normal(0.0, pow(self.onodes, -0.5), (self.onodes, self.hnodes)) # activate function self.activate_function = lambda x: scipy.special.expit(x) # train: update weights def train(self, inputs_list, targets_list): # convert to Array (why 2D?) inputs = numpy.array(inputs_list, ndmin=2).T targets = numpy.array(targets_list, ndmin=2).T # matrix computing hidden_inputs = numpy.dot(self.wih, inputs) hidden_outputs = self.activate_function(hidden_inputs) final_inputs = numpy.dot(self.who,hidden_outputs) final_outputs = self.activate_function(final_inputs) output_errors = targets - final_outputs # go back hidden_errors = numpy.dot(self.who.T, output_errors) input_errors = numpy.dot(self.wih.T, hidden_errors) # update self.who += self.lr * numpy.dot(output_errors * final_outputs * (1.0 - final_outputs), numpy.transpose(hidden_outputs)) self.wih += self.lr * numpy.dot(hidden_errors * hidden_outputs * (1.0 - hidden_outputs), numpy.transpose(inputs)) # query: take input and compute output def query(self,inputs_list): # convert to Array (why 2D?) inputs = numpy.array(inputs_list, ndmin=2).T # matrix computing hidden_inputs = numpy.dot(self.wih, inputs) hidden_outputs = self.activate_function(hidden_inputs) final_inputs = numpy.dot(self.who,hidden_outputs) final_outputs = self.activate_function(final_inputs) return final_outputs # set parameters input_nodes = 784 # 28*28 hidden_nodes = 100 output_nodes = 10 learning_rate = 0.3 nn = neuralNetwork(input_nodes, hidden_nodes, output_nodes, learning_rate) training_data_file = open(\"mnist_dataset/mnist_train_100.csv\", \"r\") training_data_list =training_data_file.readlines() training_data_file.close() epochs = 5 for e in range(epochs): for record in training_data_list: all_values = record.split(\",\") inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01 # ideal and practial targets targets = numpy.zeros(output_nodes) + 0.01 targets[int(all_values[0])] = 0.99 # start training! nn.train(inputs, targets) print(\"epoch\", e, \"done\") test_data_file = open(\"mnist_dataset/mnist_test_10.csv\", \"r\") test_data_list =test_data_file.readlines() test_data_file.close() # test the neural network # scorecard for how well the network performs, initially empty scorecard = [] # go through all the records in the test data set for record in test_data_list: # split the record by the ',' commas all_values = record.split(',') # correct answer is first value correct_label = int(all_values[0]) print(correct_label, \"correct label\") # scale and shift the inputs inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01 # query the network outputs = nn.query(inputs) # the index of the highest value corresponds to the label label = numpy.argmax(outputs) print(label, \"network's answer\") # append correct or incorrect to list if (label == correct_label): # network's answer matches correct answer, add 1 to scorecard scorecard.append(1) else: # network's answer doesn't match correct answer, add 0 to scorecard scorecard.append(0) pass print(scorecard) scorecard_array = numpy.asarray(scorecard) print (\"performance = \", scorecard_array.sum() / scorecard_array.size) 依赖文件： mnist_test_10.csv mnist_train_100.csv 作者repo ","date":"2023-07-17","objectID":"/techBlog/posts/neural_network/:4:0","tags":["神经网络"],"title":"神经网络入门-MINIST（未完待续）","uri":"/techBlog/posts/neural_network/"},{"categories":null,"content":"What I understand about linux 绪论 ","date":"2023-06-16","objectID":"/techBlog/posts/linux-basic/:0:0","tags":null,"title":"linux基础","uri":"/techBlog/posts/linux-basic/"},{"categories":null,"content":"bash shell 通过bash shell与之交互，这个程序是bash，shell的一种，图形界面应该叫terminal（在Windows里面叫cmd） 可执行文件.o一般是不显示后缀的 ./hello是因为外部指令的原理，./其实就是字面意思，从当前目录下找到hello.o /表示root，~一般就是/home/user是默认路径，输入cd就会调到默认路径 gcc一般也可以用cc代替 一些常用的shell命令还是要熟悉的： 重定向 后台执行 子shell 环境变量 进阶一点的实用命令： strace sar ldd ","date":"2023-06-16","objectID":"/techBlog/posts/linux-basic/:1:0","tags":null,"title":"linux基础","uri":"/techBlog/posts/linux-basic/"},{"categories":null,"content":"linux C linux的C语言依赖于标准库glibc，这里面在ISO定义的标准库之上增加了系统调用库的封装（帮写了汇编语言里的系统调用） 主要是在： #include \u003cuinstd.h\u003e 还有一些在别的.h文件内 OS提供的库：系统调用库 OS提供的程序：在shell中的一些指令，甚至是bash shell本身 进程管理 libc syscall fork() clone() execve() execve() ","date":"2023-06-16","objectID":"/techBlog/posts/linux-basic/:2:0","tags":null,"title":"linux基础","uri":"/techBlog/posts/linux-basic/"},{"categories":null,"content":"文件权限 /etc/passwd 记录了用户信息 分三类：root, 用户账户，系统功能账户 每一行的格式： zongwei:x:1000:1000:zongwei,,,:/home/zongwei:/bin/bash 登录名：密码（隐藏了）：UID：组ID：备注：默认目录：默认Shell 密码保存至/etc/shadow下面，root才有权限访问，不过如果有sudo权限是可以修改root密码的 $ sudo passwd root ... $ su $ exit 但是cat出来也看不懂，它经过了加密机制 组内可以共享权限设置 Ubuntu会为每个用户创建一个单独的与用户账户同名的组 查看文件权限：ls -l 第一个字符：-文件，d目录，l链接 … 后面9个字符每3个为一组：属主权限-同组用户权限-其它用户权限 r读 w写 x可执行 如果没有这个权限就是-来占位 创建文件时是用的默认权限，用unmask可以修改默认，但比较难 对已有的文件进行权限修改：chmod 改变文件属主：chown，属组chgrp （root才可以用） 下载下来的.run文件一般是没有可运行的权限的，需要赋予 ","date":"2023-06-16","objectID":"/techBlog/posts/linux-basic/:3:0","tags":null,"title":"linux基础","uri":"/techBlog/posts/linux-basic/"},{"categories":["coding"],"content":"从Makefile入门，逐步推进到CMake ","date":"2023-06-13","objectID":"/techBlog/posts/makefile/:0:0","tags":["系统开发"],"title":"Makefile基础","uri":"/techBlog/posts/makefile/"},{"categories":["coding"],"content":"几个概念 编译源文件，需要gcc 但对于大型项目多个文件，需要专门的构建(build)工具，（有些库是需要手动加进去的，比如lpthread，所以要有脚本） Make就是这样的工具，它需要makefile脚本来知道怎么编译 而makefile的生成可以由Cmake来生成，根据CMakeList.txt文件来生成（自己写Makefile有时也很麻烦，而CMakeList.txt更简单一些） 像Visual Studio这种有专门的内置build tools The goal of Makefiles is to compile whatever files need to be compiled, based on what files have changed. ","date":"2023-06-13","objectID":"/techBlog/posts/makefile/:1:0","tags":["系统开发"],"title":"Makefile基础","uri":"/techBlog/posts/makefile/"},{"categories":["coding"],"content":"makefile语法 targets: [prerequisites] command command command targets: 生成的目标文件名 （可去后缀） prerequisities: 可选，需要存在的文件 command: 具体的命令，一定是Tab开头，采用的也是shell指令 举例： blah: blah.c cc blah.c -o blah 如果blah文件不存在则会执行 如果已存在，会和blah.c比较是否发生改动，然后决定要不要执行 ​ 具体是通过修改时间来判断的，timestamps ","date":"2023-06-13","objectID":"/techBlog/posts/makefile/:2:0","tags":["系统开发"],"title":"Makefile基础","uri":"/techBlog/posts/makefile/"},{"categories":["coding"],"content":"targets概念 如果想让Makefile里面每一个都执行： 定义一个all all: one two three one: touch one two: touch two three: touch three clean: rm -f one two three 这样默认是执行all，但是发现one two three都不存在，需要先执行它们 另外target部分可以是多个： all: f1.o f2.o f1.o f2.o: echo $@ ","date":"2023-06-13","objectID":"/techBlog/posts/makefile/:2:1","tags":["系统开发"],"title":"Makefile基础","uri":"/techBlog/posts/makefile/"},{"categories":["coding"],"content":"Variables 首先数据类型都是字符串，所以也不必打引号，通过:=符号赋值，可以多个赋给一个，等同于define 然后引用变量：$(x) 还有转义字符，但要注意使用，以防被理解为普通字符 * ：匹配文件名，一般使用它时需要声明： thing_right := $(wildcard *.o) 这等同于把所有.o文件名赋给thing_right %：比较复杂，之后再将 还有一些自动变量，类似matlab里的ans @: 代表target名 ^: 代表所有的prerequisites ?: 代表相比于target有更新的prerequisites make有一种自动编译c/c++的机制，不需要自己写 编译C：$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@ 编译CPP：$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@ 链接.o文件：$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@ 只需要给CC CXX这些变量赋值即可 CC = gcc # Flag for implicit rules CFLAGS = -g # Flag for implicit rules. Turn on debug info # Implicit rule #1: blah is built via the C linker implicit rule # Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists blah: blah.o blah.c: echo \"int main() { return 0; }\" \u003e blah.c clean: rm -f blah* 这里就会自己给编译blah.c filter函数： $(filter %.o,$(obj_files)): %.o: %.c echo \"target: $@ prereq: $\u003c\" ","date":"2023-06-13","objectID":"/techBlog/posts/makefile/:2:2","tags":["系统开发"],"title":"Makefile基础","uri":"/techBlog/posts/makefile/"},{"categories":["coding"],"content":"链表的归并排序算法 归并排序主要就是分段+合并，可以自顶向下，也可以自底向上 ","date":"2023-06-05","objectID":"/techBlog/posts/merge-sort/:0:0","tags":["链表","排序"],"title":"链表归并排序","uri":"/techBlog/posts/merge-sort/"},{"categories":["coding"],"content":"合并 合并已经有基础：合并两个有序链表 也没有什么花招，就是两边同时出发遍历，只是写起来相对麻烦 leetcode官方给的合并算法： ListNode* merge(ListNode* head1, ListNode* head2) { ListNode* dummyHead = new ListNode(0); ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2; while (temp1 != nullptr \u0026\u0026 temp2 != nullptr) { if (temp1-\u003eval \u003c= temp2-\u003eval) { temp-\u003enext = temp1; temp1 = temp1-\u003enext; } else { temp-\u003enext = temp2; temp2 = temp2-\u003enext; } temp = temp-\u003enext; } if (temp1 != nullptr) { temp-\u003enext = temp1; } else if (temp2 != nullptr) { temp-\u003enext = temp2; } return dummyHead-\u003enext; } 优点在于增加了一个虚拟头节点，使得统一性更好，不必单独判断第一个 ","date":"2023-06-05","objectID":"/techBlog/posts/merge-sort/:1:0","tags":["链表","排序"],"title":"链表归并排序","uri":"/techBlog/posts/merge-sort/"},{"categories":["coding"],"content":"自底向上方法 每两个合并一下，为了能够表示，使用subLength这个变量来划分 先取出来，排序好，再链回路 挺烦的 ","date":"2023-06-05","objectID":"/techBlog/posts/merge-sort/:2:0","tags":["链表","排序"],"title":"链表归并排序","uri":"/techBlog/posts/merge-sort/"},{"categories":["coding"],"content":"自顶向下方法 指定头尾，不断二分，递归的方法 找到中间节点可以用快慢指针 感觉还是递归简单一点 ","date":"2023-06-05","objectID":"/techBlog/posts/merge-sort/:3:0","tags":["链表","排序"],"title":"链表归并排序","uri":"/techBlog/posts/merge-sort/"},{"categories":["Development"],"content":"采用DMA方式用DAC输出正弦波 ","date":"2023-05-19","objectID":"/techBlog/posts/stm32_dac_dma/:0:0","tags":["STM32"],"title":"STM32 DAC+DMA 输出正弦波","uri":"/techBlog/posts/stm32_dac_dma/"},{"categories":["Development"],"content":"DAC 我们希望每隔一定时间输出一个电压值 这需要DAC到时间被触发Trigger，所以，对DAC的配置是： 这里Trigger选择了定时器5来触发DAC，其它几个参数可无视，并没有很大影响 注意：STM32L496ZG的DAC只有一个，且通道固定是PA4, PA5，而这个引脚也同时是SPI1的默认引脚，注意不要公用时冲突 同时，DAC要转换的数值由DMA提供，从内存中直接经其通道传输给DAC的通道进行转换 需要配置其DMA，添加： 表示将内存中的数值送到DAC_CH1，也就是PA4，注意选择circluar，这样才可以循环输出产生持续的正弦波 ","date":"2023-05-19","objectID":"/techBlog/posts/stm32_dac_dma/:1:0","tags":["STM32"],"title":"STM32 DAC+DMA 输出正弦波","uri":"/techBlog/posts/stm32_dac_dma/"},{"categories":["Development"],"content":"TIM 定时器需要让它产生Trigger信号 这里的update event指的就是定时器计数器满，定时器计数值满后就会触发DAC，这里的触发不是中断 所以定时器触发的频率等同于采样率 ","date":"2023-05-19","objectID":"/techBlog/posts/stm32_dac_dma/:2:0","tags":["STM32"],"title":"STM32 DAC+DMA 输出正弦波","uri":"/techBlog/posts/stm32_dac_dma/"},{"categories":["Development"],"content":"程序 启动： HAL_TIM_Base_Start(\u0026htim5); // 启动tim5 无需中断 HAL_DAC_Start_DMA(\u0026hdac1, DAC_CHANNEL_1, (uint32_t *)Sine12bit, 100, DAC_ALIGN_12B_R); // 启动DAC_DMA模式 这样就可以把Sine12bit输出了 \u0026hdac1指出了dac对象，DAC_CHHANNEL_1为通道，SIine12bit传输的是指针，代表的是内存地址，也就是输出的源地址，100是数量，DAC_ALIGN_12B_R代表对齐方式，这个和寄存器有关，这里不细讲了 这里提供一个Sine12bit数组： const uint16_t Sine12bit[100]={ 0x0800,0x0881,0x0901,0x0980,0x09FD,0x0A79,0x0AF2,0x0B68,0x0BDA,0x0C49, 0x0CB3,0x0D19,0x0D79,0x0DD4,0x0E29,0x0E78,0x0EC0,0x0F02,0x0F3C,0x0F6F, 0x0F9B,0x0FBF,0x0FDB,0x0FEF,0x0FFB,0x0FFF,0x0FFB,0x0FEF,0x0FDB,0x0FBF, 0x0F9B,0x0F6F,0x0F3C,0x0F02,0x0EC0,0x0E78,0x0E29,0x0DD4,0x0D79,0x0D19, 0x0CB3,0x0C49,0x0BDA,0x0B68,0x0AF2,0x0A79,0x09FD,0x0980,0x0901,0x0881, 0x0800,0x077F,0x06FF,0x0680,0x0603,0x0587,0x050E,0x0498,0x0426,0x03B7, 0x034D,0x02E7,0x0287,0x022C,0x01D7,0x0188,0x0140,0x00FE,0x00C4,0x0091, 0x0065,0x0041,0x0025,0x0011,0x0005,0x0001,0x0005,0x0011,0x0025,0x0041, 0x0065,0x0091,0x00C4,0x00FE,0x0140,0x0188,0x01D7,0x022C,0x0287,0x02E7, 0x034D,0x03B7,0x0426,0x0498,0x050E,0x0587,0x0603,0x0680,0x06FF,0x077F, }; 这里是$0 \\sim 2^{12} -1$的值，转换成电压为 $0 \\sim 3.3V$ 在PA4处便可得到正弦波： PS. 当试图用DAC做信号发生器时要考虑接口电流电压特性是否能够带得动外设，比如扬声器模块就需要前置级，不能直接驱动 ","date":"2023-05-19","objectID":"/techBlog/posts/stm32_dac_dma/:3:0","tags":["STM32"],"title":"STM32 DAC+DMA 输出正弦波","uri":"/techBlog/posts/stm32_dac_dma/"},{"categories":["Development"],"content":"基于定时器实现对较高频率的测量 捕获模式（测周法） 定时器可以对输入的PWM波进行边缘检测，同时也可以发出PWM波 定时器内部自己在对时钟进行计数，到达一定值(AAR)后重载为0 最开始想的是测频法，因为这样不仅可以测周期还可以调整捕获的极性以测占空比，但实验发现在频率上了$kHz$就有问题了，而且是难以言明的问题，捕获和计数器变得不靠谱起来，所以这个方法也还是只适合低频 ","date":"2023-05-13","objectID":"/techBlog/posts/stm32l4-timer/:0:0","tags":["STM32"],"title":"STM32 定时器测量高频率","uri":"/techBlog/posts/stm32l4-timer/"},{"categories":["Development"],"content":"生成 PWM波 先设置一个定时器的时钟为内部时钟Internal Clock，值就是时钟图里的HCLK，配置一个通道为PWM Generation CHx 然后设置它的： PSC：预分频系数，$\\mathrm{HCLK} / (\\mathrm{PSC}+1)$ 才是定时器的内部时钟频率 counter period：这个决定了PWM波的周期（注意也要-1），计数到这个值后归零 pulse: 这个和period决定了占空比 比如这里，如果HCLK设置的是50MHz（在时钟图里改），那么定时器的内部时钟频率就是： $$ \\mathrm{CLK_{internal}} = \\frac{50M}{500} = 100 \\mathrm{kHz} $$ 产生的PWM波频率是： $$ f = \\frac{100k}{100} = 1 \\mathrm{kHz} $$ 占空比为： $$ duty = \\frac{50}{100} * 100% = 50% $$ 为向上的高电平 在main.c里面使用 HAL_TIM_PWM_Start(\u0026htim3, TIM_CHANNEL_1); // 启动PWM 如此便能生成了，在对应的引脚便可得到 ","date":"2023-05-13","objectID":"/techBlog/posts/stm32l4-timer/:1:0","tags":["STM32"],"title":"STM32 定时器测量高频率","uri":"/techBlog/posts/stm32l4-timer/"},{"categories":["Development"],"content":"内部时钟-捕获 通道选择Input Capture Direct Mode 然后内部时钟也是一样有个预分频系数可以设置 然后设置AAR即自动重载值，计数器计到这个就会自动归0 极性选择上升沿，它就会捕获输入信号的上升沿，注意开启中断 它的计数器频率同理 在程序中调用 HAL_TIM_Base_Start_IT(\u0026htim4); 这样其实就同时开启了捕获中断和溢出中断，也可以分别开启 void _HAL_TIM_ENABLE_IT(\u0026htim4, TIM_IT_UPDATE); //溢出中断 void HAL_TIM_IC_Start_IT(\u0026htim4,TIM_CHANNEL_1); // IC捕获中断 回调函数是： void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim); // 溢出回调 void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim); // 捕获回调函数 修改极性的办法： __HAL_TIM_SET_CAPTUREPOLARITY(\u0026htim4,TIM_CHANNEL_1,TIM_INPUTCHANNELPOLARITY_FALLING); //设置成下降沿触发 当捕获到上升沿后，在回调函数内切换为捕获下降沿，再次捕获，根据两次的计数值和中间溢出的次数就可以算出输入的信号的脉宽 外部时钟（测频法） 定时器的计数器所作用的时钟是可以改成外部时钟的 最开始想到测频法，还是利用的输入捕获的方式，也就是自己定义一个变量，捕获一次就+1这种想法，这种由于回调函数内容变得只有一行： void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){ cnt ++; } 所以它确实能够提高测量的频率上限，但是在测到1MHz还是不行了 本来打算麻烦队友改电路降低频率了，但是我又在睡着前想到：单片机有能力对50MHz的HCLK进行分频，那么肯定不会说1MHz的频率太快了来不及响应 然后我想到之间把输入信号接到定时器上去，替换原本的内部时钟，这样就和分频是一样的道理，肯定是能够记录到脉冲个数的 事实确实如此 定时器可以通过外部时钟触发计数，经过实验也得到验证，10MHz也不是问题了 配置方法： CubeMX里面：定时器Clock Source选择ETR2即可，无需中断，无需配置channel，它有写死的一个TIMx_ETR通道，将外部信号接到这个就行了 它会自动对外接的信号进行计数，所以也需要配置一下预分频和重载值，就等同于平替了原来的HCLK 在程序中： 启动： HAL_TIM_Base_Start(\u0026htim2); TIM2-\u003eCNT = 0; 然后设以TIM4作为参考时钟，设置其溢出中断间隔为1s即1Hz，溢出时在其回调函数内读取TIM2的CNT即可（配置好TIM2不会计数溢出） 就这么简单 ","date":"2023-05-13","objectID":"/techBlog/posts/stm32l4-timer/:2:0","tags":["STM32"],"title":"STM32 定时器测量高频率","uri":"/techBlog/posts/stm32l4-timer/"},{"categories":["Development"],"content":"本文以STM32L496为例介绍如何在HAL库下驱动OLED ","date":"2023-05-04","objectID":"/techBlog/posts/stm32l4-oled/:0:0","tags":["STM32"],"title":"基于HAL库的OLED驱动方法 (SPI)","uri":"/techBlog/posts/stm32l4-oled/"},{"categories":["Development"],"content":"写在前面 网络上也有不少用HAL库的工程，但实验并未成功，目前也没有想清楚为什么，此处仅介绍成功的一种驱动方法 ","date":"2023-05-04","objectID":"/techBlog/posts/stm32l4-oled/:1:0","tags":["STM32"],"title":"基于HAL库的OLED驱动方法 (SPI)","uri":"/techBlog/posts/stm32l4-oled/"},{"categories":["Development"],"content":"核心部分 CSDN，淘宝找到一个用HAL库的工程： 核心完全是GPIO口的配置，在oled.c文件内存在一个OLED_Init()函数，这里面会对GPIO口重新配置，所以不仅仅是改oled.h文件那里对引脚的重定义 假设在Cube里配置成和这里一样，然后注释掉这里，理论上应该能行，但保险起见还是别这样 最方便的就是别改，就按着给定连线就行，马上就能用 为了能够增加灵活性我将这里进行了修改，以后只需要在Cube里定义好同样的别名就行了 void OLED_Init(void) { GPIO_InitTypeDef GPIO_InitStruct; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOH_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOC_CLK_ENABLE(); __HAL_RCC_GPIOD_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); OLED_SCLK_Set(); OLED_SDIN_Set(); OLED_CS_Set(); OLED_RST_Set(); OLED_DC_Set(); LED_ON; /*Configure GPIO pins*/ GPIO_InitStruct.Pin = SCK_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; //这里和spi.c里面还是不一样 GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(SCK_GPIO_Port, \u0026GPIO_InitStruct); GPIO_InitStruct.Pin = SDA_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; //这里和spi.c里面还是不一样 GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(SDA_GPIO_Port, \u0026GPIO_InitStruct); GPIO_InitStruct.Pin = OLED_CS_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; //这里和spi.c里面还是不一样 GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(OLED_CS_GPIO_Port, \u0026GPIO_InitStruct); GPIO_InitStruct.Pin = LD2_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, \u0026GPIO_InitStruct); GPIO_InitStruct.Pin = OLED_RST_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(OLED_RST_GPIO_Port, \u0026GPIO_InitStruct); /*Configure GPIO pin : PtPin */ GPIO_InitStruct.Pin = OLED_DC_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(OLED_DC_GPIO_Port, \u0026GPIO_InitStruct); OLED_RST_Clr(); HAL_Delay(200); OLED_RST_Set(); OLED_WR_Byte(0xAE,OLED_CMD);//--turn off oled panel OLED_WR_Byte(0x00,OLED_CMD);//---set low column address OLED_WR_Byte(0x10,OLED_CMD);//---set high column address OLED_WR_Byte(0x40,OLED_CMD);//--set start line address Set Mapping RAM Display Start Line (0x00~0x3F) OLED_WR_Byte(0x81,OLED_CMD);//--set contrast control register OLED_WR_Byte(0xCF,OLED_CMD);// Set SEG Output Current Brightness OLED_WR_Byte(0xA1,OLED_CMD);//--Set SEG/Column Mapping 0xa0左右反置 0xa1正常 OLED_WR_Byte(0xC8,OLED_CMD);//Set COM/Row Scan Direction 0xc0上下反置 0xc8正常 OLED_WR_Byte(0xA6,OLED_CMD);//--set normal display OLED_WR_Byte(0xA8,OLED_CMD);//--set multiplex ratio(1 to 64) OLED_WR_Byte(0x3f,OLED_CMD);//--1/64 duty OLED_WR_Byte(0xD3,OLED_CMD);//-set display offset Shift Mapping RAM Counter (0x00~0x3F) OLED_WR_Byte(0x00,OLED_CMD);//-not offset OLED_WR_Byte(0xd5,OLED_CMD);//--set display clock divide ratio/oscillator frequency OLED_WR_Byte(0x80,OLED_CMD);//--set divide ratio, Set Clock as 100 Frames/Sec OLED_WR_Byte(0xD9,OLED_CMD);//--set pre-charge period OLED_WR_Byte(0xF1,OLED_CMD);//Set Pre-Charge as 15 Clocks \u0026 Discharge as 1 Clock OLED_WR_Byte(0xDA,OLED_CMD);//--set com pins hardware configuration OLED_WR_Byte(0x12,OLED_CMD); OLED_WR_Byte(0xDB,OLED_CMD);//--set vcomh OLED_WR_Byte(0x40,OLED_CMD);//Set VCOM Deselect Level OLED_WR_Byte(0x20,OLED_CMD);//-Set Page Addressing Mode (0x00/0x01/0x02) OLED_WR_Byte(0x02,OLED_CMD);// OLED_WR_Byte(0x8D,OLED_CMD);//--set Charge Pump enable/disable OLED_WR_Byte(0x14,OLED_CMD);//--set(0x10) disable OLED_WR_Byte(0xA4,OLED_CMD);// Disable Entire Display On (0xa4/0xa5) OLED_WR_Byte(0xA6,OLED_CMD);// Disable Inverse Display On (0xa6/a7) OLED_WR_Byte(0xAF,OLED_CMD); OLED_Clear(); } #define OLED_SCLK_Clr() HAL_GPIO_WritePin(SCK_GPIO_Port, SCK_Pin, GPIO_PIN_RESET);//CLK #define OLED_SCLK_Set() HAL_GPIO_WritePin(SCK_GPIO_Port, SCK_Pin, GPIO_PIN_SET); #define OLED_SDIN_Clr() HAL_GPIO_WritePin(SDA_GPIO_Port, SDA_Pin, GPIO_PIN_RESET)//DIN #define OLED_SDIN_Set() HAL_GPIO_WritePin(SDA_GPIO_Port, SDA_Pin, GPIO_PIN_SET) #def","date":"2023-05-04","objectID":"/techBlog/posts/stm32l4-oled/:2:0","tags":["STM32"],"title":"基于HAL库的OLED驱动方法 (SPI)","uri":"/techBlog/posts/stm32l4-oled/"},{"categories":["Development"],"content":"个性化 如果一直放在while循环里循环显示，则会阻塞到其它功能 其实只需要show一次即可 HAL_Delay(500); OLED_Clear(); OLED_ShowNum(103,48,24,3,16); // show num 24 OLED_Refresh(); 103,48 是坐标；3是位数，表示显示的是024；16是字号大小 注意，字号只有16，24，32，64，分别对应于oledfont.h的Hzk1~4 用取模软件得到字符，放入Hzk数组其中即可，可参考其几个Show函数的实现 核心源文件 ","date":"2023-05-04","objectID":"/techBlog/posts/stm32l4-oled/:3:0","tags":["STM32"],"title":"基于HAL库的OLED驱动方法 (SPI)","uri":"/techBlog/posts/stm32l4-oled/"},{"categories":["coding"],"content":"topological sort","date":"2023-05-04","objectID":"/techBlog/posts/topological-sort/","tags":["图"],"title":"拓扑排序","uri":"/techBlog/posts/topological-sort/"},{"categories":["coding"],"content":"拓扑排序简单来说就是剥皮 ","date":"2023-05-04","objectID":"/techBlog/posts/topological-sort/:0:0","tags":["图"],"title":"拓扑排序","uri":"/techBlog/posts/topological-sort/"},{"categories":["coding"],"content":"依赖关系和环 课程表先修问题 华为机考的题 ","date":"2023-05-04","objectID":"/techBlog/posts/topological-sort/:1:0","tags":["图"],"title":"拓扑排序","uri":"/techBlog/posts/topological-sort/"},{"categories":["coding"],"content":"最小高度 从最简单的情况开始，逐步加上去，就不难发现这个规律了 leetcode t310 class Solution { // 拓扑排序 public: vector\u003cint\u003e findMinHeightTrees(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 edges) { // 要想到拓扑排序，首先得意识到，这个最短树它其实是可以一层一层给剖出来的 // 没有认识到这个规律就想不到拓扑排序 vector\u003cint\u003e res; //! 总有比较奇葩的特殊情况 if (n == 1) { res.push_back(0); return res; } // todo 邻接表（比邻接矩阵好一些） vector\u003cvector\u003cint\u003e\u003e adjMap(n); vector\u003cint\u003e degree(n,0); // 记录度的表，拓扑排序需要这个 for (auto edge: edges){ adjMap[edge[0]].push_back(edge[1]); adjMap[edge[1]].push_back(edge[0]); degree[edge[0]]++; degree[edge[1]]++; } queue\u003cint\u003e leaves; // todo 加入叶子节点（度为1的） for (int i = 0; i \u003c n; i++){ if (degree[i]==1) leaves.push(i); } // todo BFS遍历，一直到最后一层就是最短树的节点了，这是建立在认识到的规律得出的结论上的 while (!leaves.empty()) { // todo 叶子节点取出来，要放进res里面，后面会被更新，最后在其中的就是目标 res.clear(); //* 需要更新 // todo 取出这一层叶子节点的方法 //? 我之前想的是队列放入的是一个个向量，但其实可以通过个数来做到 int sz = leaves.size(); for (int i = 0; i \u003c sz; i++){ // 出队多少次 int leaf = leaves.front(); leaves.pop(); res.push_back(leaf); // 放入res // todo 出队后，更新度和相邻节点的度 degree[leaf]--; //? 这还是必要的 for (auto neibor: adjMap[leaf]){ degree[neibor]--; if (degree[neibor] == 1) leaves.push(neibor); //? 在这里就顺便一起判断了 } } } return res; } }; ","date":"2023-05-04","objectID":"/techBlog/posts/topological-sort/:2:0","tags":["图"],"title":"拓扑排序","uri":"/techBlog/posts/topological-sort/"},{"categories":["coding"],"content":"定义的安全节点 其实感觉和最小高度类似，想必也是有类似的规律，只是这次不见得是度为1的 leetcode t802 class Solution { public: vector\u003cint\u003e eventualSafeNodes(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { // 出度为0是终端节点 // graph[i]中都是终端节点的是安全节点 // 终端节点一定是安全节点 // 如果去掉第一层终端节点，新产生的终端节点在原来的图上一定是都连向终端节点的，因此也一定是安全节点 // 如果去掉第二层终端节点，新产生的终端节点在原来的图上，一定有连向第二层的，那么就不是安全节点 // 所以应该就只是前两层的终端节点？还是都是？好吧，这也算 vector\u003cint\u003e res; int N = graph.size(); vector\u003cint\u003e degree(N); queue\u003cint\u003e terminals; // todo 还需要一个入的graph vector\u003cvector\u003cint\u003e\u003e parents(N); for (int i = 0; i \u003c N; i++){ degree[i] = graph[i].size(); if (degree[i] == 0) terminals.push(i); for (auto cd : graph[i]){ parents[cd].push_back(i); } } int cnt = 0; while (cnt !=2 \u0026\u0026 !terminals.empty()){ //只看前两层 int sz = terminals.size(); for (int i = 0; i \u003c sz; i++){ int tml = terminals.front(); terminals.pop(); res.push_back(tml); degree[tml] --; for (auto neibor : parents[tml]){ degree[neibor]--; if (degree[neibor] == 0) terminals.push(neibor); } } cnt ++; } sort(res.begin(), res.end()); return res; } }; ","date":"2023-05-04","objectID":"/techBlog/posts/topological-sort/:3:0","tags":["图"],"title":"拓扑排序","uri":"/techBlog/posts/topological-sort/"},{"categories":["coding"],"content":"shortest path","date":"2023-05-04","objectID":"/techBlog/posts/shortest-path/","tags":["图"],"title":"最短路问题","uri":"/techBlog/posts/shortest-path/"},{"categories":["coding"],"content":"此处主要主要介绍两种算法 ","date":"2023-05-04","objectID":"/techBlog/posts/shortest-path/:0:0","tags":["图"],"title":"最短路问题","uri":"/techBlog/posts/shortest-path/"},{"categories":["coding"],"content":"Dijkstra 算法 贪心算法，和最小生成树的Prim算法很接近，只是是以起点为中心找总的最短的路径，会那个就会这个 ","date":"2023-05-04","objectID":"/techBlog/posts/shortest-path/:1:0","tags":["图"],"title":"最短路问题","uri":"/techBlog/posts/shortest-path/"},{"categories":["coding"],"content":"Floyd 算法 运用了动态规划的思想，状态转移方程为： $$ dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); $$ 即，节点i和j之间的最短路径，应当是比较【直达】还是【换乘】 开始数组dist初始化为任意两个节点之间的路径，然后三重循环遍历 for (int k = 0; k \u003c v; ++k){ for (int i = 0; i \u003c v; ++i){ for (int j = 0; j \u003c v; ++j){ dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } } } 这个先后顺序应该是有影响的，还是画矩阵图比较好记 ","date":"2023-05-04","objectID":"/techBlog/posts/shortest-path/:2:0","tags":["图"],"title":"最短路问题","uri":"/techBlog/posts/shortest-path/"},{"categories":["coding"],"content":"Bellman-Ford 算法 适合那种限制经过的边数、节点数的问题 核心算法： for (auto i = 0; i \u003c n - 1; i++) { for (auto j = 0; j \u003c m; j++) {//对m条边进行循环 auto edge = edges[j]; // 松弛操作 auto dist_tmp = distance; // 保证在同一次下彼此不受影响 if (distance[edge.to] \u003e dist_tmp[edge.from] + edge.weight ){ // 小心溢出 distance[edge.to] = dist_tmp[edge.from] + edge.weight; } } } 刚开始源点到其它节点的距离都是INF，那么i=0时只有从源点出发的边能够被修改，完成后代表的是只能经过1点边情况下的最短路径 依次类推，遍历完i时距离表表示的是最多能经过i+1条边所用的最短距离 ","date":"2023-05-04","objectID":"/techBlog/posts/shortest-path/:3:0","tags":["图"],"title":"最短路问题","uri":"/techBlog/posts/shortest-path/"},{"categories":["coding"],"content":"min tree","date":"2023-04-23","objectID":"/techBlog/posts/minimum-spanning-tree/","tags":["图"],"title":"最小生成树","uri":"/techBlog/posts/minimum-spanning-tree/"},{"categories":["coding"],"content":"此处主要记录最小生成树的个人理解，目标是为了个人复习，而不是为了讲清楚 一张图的树可以有很多种，找到权重和最小的那棵树 Prim 算法 前置工作：得到邻接矩阵 输入部分可能要想一想怎么构建出邻接矩阵 邻接矩阵的值： 0：表示自己（后面也顺便成了访问过的标记） INF：表示不直接相连 正整数：表示权重（距离） 假设从v0节点开始，先取出邻接矩阵的该行，表示的是到其它各个节点的距离（也包括了自己） 现在有两个数组，一个用于记录到其它节点的距离（权重），另一个表示是从哪个节点看过去的，刚开始都是从v0出发来看的，因此初始化为0，即v0的id 遍历剩余的节点 找到距离最近的那个（擂台法）（0距离的不参与） 记录这个节点的id 从这个节点出发看其它节点的距离，与原来数组的值比较，取最小的，如果从这个节点更近，则需要修改出发节点为该节点id（主要是为了输出） 这样距离数组就是这个节点和初始节点（前面的节点）作为一个整体到其它节点的距离了 为了避免重复，要把以及访问过的节点在距离数组中都改为0，这样就不会把访问过的也拿进去参与比较 这样直至整个距离数组都是0了 注意，起始节点可以是任意一个 与Dijkstra的区别是这个是找相对于这个整体最近的，而Dijkstra永远是找从起始节点出发最短的路，比较的是直接到达和简介抵达哪个最短 Kruskal 算法 与上一个不同，这个要构建边集 边集数组记录改边连通的起始节点和终止节点，以及距离 思想就是：首先进行排序，依次取出最小的边，跳过会让图形成回路的边就完事了 主要是如何判断已经形成了回路 定义一个终点节点数组，记录每个节点的最小生成树的终止节点 刚开始都初始化为0 考虑如果放入一条边：查找这条边的起始节点和终止节点 如果该节点在终止数组里面不为0，就顺着找下去，直到为0，这个过程相当于是在沿着节点所在的树走直到走到终点，那么如果放入这点边，我应该把这个终点和终止节点的终点连上，让它合并为一棵树 如果它们找到了相同的终点，则说明已经在同一颗树里面，连上则会形成回路，因此不能要 ","date":"2023-04-23","objectID":"/techBlog/posts/minimum-spanning-tree/:0:0","tags":["图"],"title":"最小生成树","uri":"/techBlog/posts/minimum-spanning-tree/"},{"categories":["Development"],"content":"qt usage tutorial","date":"2023-04-21","objectID":"/techBlog/posts/qt-creator-serialport/","tags":["Qt","串口"],"title":"Qt 开发上位机程序","uri":"/techBlog/posts/qt-creator-serialport/"},{"categories":["Development"],"content":"利用Qt creator 开发一个上位机程序，能够实现显示单片机返回的数据，增加展示效果，但可调式性必然没有以及成熟的好 ","date":"2023-04-21","objectID":"/techBlog/posts/qt-creator-serialport/:0:0","tags":["Qt","串口"],"title":"Qt 开发上位机程序","uri":"/techBlog/posts/qt-creator-serialport/"},{"categories":["Development"],"content":"基本认识 Qt 生成一个主窗口，然后会陷入事件循环，直至用户关闭程序才会执行main函数后面的代码 Qt 生成的窗口样式是和操作系统相关的，Qt 可以设置一些属性，但一些特别的属性依赖于系统主题，Qt 无法控制，所以改了也没有用 QMainWindow继承自QWidget，增加了菜单栏、状态栏之类的东西，比如经常有看到的“文件、工具”等待选项，这些并非是必要的 在ui界面上的东西，是属于ui这个对象的成员 ","date":"2023-04-21","objectID":"/techBlog/posts/qt-creator-serialport/:1:0","tags":["Qt","串口"],"title":"Qt 开发上位机程序","uri":"/techBlog/posts/qt-creator-serialport/"},{"categories":["Development"],"content":"自定义窗口 如果完全自定义则关闭、最大化、最小化这些都要自己配置了 实在太麻烦，还是就这样了吧，win11的也不算丑了 ","date":"2023-04-21","objectID":"/techBlog/posts/qt-creator-serialport/:2:0","tags":["Qt","串口"],"title":"Qt 开发上位机程序","uri":"/techBlog/posts/qt-creator-serialport/"},{"categories":["Development"],"content":"本文基于STM32CubeMX + Keil5 的开发，介绍该型号的配置和使用方法 写在前面 重要手册： UM2179: STM32 Nucleo-144 boards (MB1312) 是NUCLEO-144系列开发板的相关手册，可谓最重要的参考文档 DS11585 是板载的MCU手册，用处不大，现在基本不会用裸机 STM32L073xx_User_Manual.chm 这个一般位于cube安装的pack里面（\\STM32Cube\\Repository\\STM32Cube_FW_L0_V1.12.2\\Drivers\\STM32L0xx_HAL_Driver），是HAL库的手册，用HAL库的都有类似的文档，因此不必纠结是不是L0系列 STM32CubeMX CubeMX最直接的好处就是可视化配置+代码框架，在其中配置好生成代码即可 CubeMX的不同版本界面差别挺大，笔者用的是 STM32CubeMX-Win 6.8.0，也建议紧跟时代用新版，免费软件没问题的 ","date":"2023-04-21","objectID":"/techBlog/posts/nucleol496zg/:0:0","tags":["STM32"],"title":"基于NUCLEO-L496ZG开发","uri":"/techBlog/posts/nucleol496zg/"},{"categories":["Development"],"content":"选型 在Pakages Manager 里面安装L4系列的MCU Pack 在new project里，直接选板子，板子和其MCU型号是对应了的，这样生成的界面才能看到一些重要管脚定义 ","date":"2023-04-21","objectID":"/techBlog/posts/nucleol496zg/:1:0","tags":["STM32"],"title":"基于NUCLEO-L496ZG开发","uri":"/techBlog/posts/nucleol496zg/"},{"categories":["Development"],"content":"配置 主要需要配置 LPUART 和 ADC LPUART 用于和PC机直接通过USB线通信（因为它是和STLINK连接的），默认是使能了的，但还需要自行配置其波特率等参数 ADC 要Enable其引脚，否则即使在引脚端选择了也还是黄色的而非绿色，要注意别忘了 如果需要用中断方式，记得配置 Global Interupt ","date":"2023-04-21","objectID":"/techBlog/posts/nucleol496zg/:2:0","tags":["STM32"],"title":"基于NUCLEO-L496ZG开发","uri":"/techBlog/posts/nucleol496zg/"},{"categories":["Development"],"content":"生成代码 注意在generate code的时候记得选分文件（不是必要，但有利于阅读） 并且要注意toolchain的最小版本是否合适 项目名字一旦取定则无法更改 Keil 在keil上需要安装l4系列的pack，注意由于官网的pack一般是新版，可能直接安装就旧版Keil上会出现这样的问题： 这个并不太会影响正常使用，作为强迫症患者最好换新版Keil 在Keil上的魔法棒（option for target)，要注意配置两个地方 target下面，勾选Use MicroLIB，这个具体什么原因笔者还未了解清楚，只知道如果不选则 LPUART发送数据会卡住，无法继续执行代码（但调试可以），所以如果用户在使用时发现拷了代码进去却没反应，有可能就是卡住了，记得检查这里 debug下面，选 use J-LINK / J-TRACE Cortex，虽然文档说是用的 STLINK V2-1，但实际插上之后显示的是JLINK设备，具体为什么也不清楚。然后在setting里面port选SW 若还有其它的问题，会在下载时报错，根据报错信息应该也能很快解决，只需耐心读 Code 编程要学会重定义 printf函数，具体做法是在main函数里： #include \"stdio.h\" int fputc(int ch, FILE *f) { HAL_UART_Transmit(\u0026hlpuart1, (uint8_t *)\u0026ch, 1 , 0xffff); return ch; } 此外注意自己加的内容放到注释里面写的 Begin - End 之间，这样在修改CubeMX之后重新生成不会把自己的代码覆盖掉 建议在VScode或者其它编辑器进行编辑，keil IAR 等软件的代码编辑界面都是否老古董，用着难受，具体配置请自行搜索 整个代码用的是HAL库，虽然在源文件里面看不到对应的include信息，但其实在Keil里面它是自己预定义过了的 网上找到教程有些不是HAL库，因此函数名不一样，HAL库的函数一般都会以HAL_开头，注意不要无脑CV 😊 ","date":"2023-04-21","objectID":"/techBlog/posts/nucleol496zg/:3:0","tags":["STM32"],"title":"基于NUCLEO-L496ZG开发","uri":"/techBlog/posts/nucleol496zg/"},{"categories":["documentation"],"content":"Discover what the Hugo - LoveIt theme is all about and the core-concepts behind it.","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"Discover what the Hugo - LoveIt theme is all about and the core-concepts behind it. ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"1 Requirements Thanks to the simplicity of Hugo, Hugo is the only dependency of this theme. Just install latest version of  Hugo (\u003e 0.62.0) for your OS (Windows, Linux, macOS). Why not support earlier versions of Hugo?\rSince Markdown Render Hooks was introduced in the Hugo Christmas Edition, this theme only supports Hugo versions above 0.62.0.\rHugo extended version is recommended\rSince some features of this theme need to processes  SCSS to  CSS, it is recommended to use Hugo extended version for better experience.\r","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"2 Installation The following steps are here to help you initialize your new website. If you don’t know Hugo at all, we strongly suggest you learn more about it by following this great documentation for beginners. ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.1 Create Your Project Hugo provides a new command to create a new website: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.2 Install the Theme The LoveIt theme’s repository is: https://github.com/dillonzq/LoveIt. You can download the latest release  .zip file of the theme and extract it in the themes directory. Alternatively, clone this repository to the themes directory: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt Or, create an empty git repository and make this repository a submodule of your site directory: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.3 Basic Configuration The following is a basic configuration for the LoveIt theme: baseURL = \"http://example.org/\" # Change the default theme to be use when building the site with Hugo theme = \"LoveIt\" # website title title = \"My New Hugo Site\" # language code [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"en\" # language name [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"English\" # Author config [author] name = \"xxxx\" email = \"\" link = \"\" # Menu config [menu] [[menu.main]] weight = 1 identifier = \"posts\" # you can add extra information before the name (HTML format is supported), such as icons pre = \"\" # you can add extra information after the name (HTML format is supported), such as icons post = \"\" name = \"Posts\" url = \"/posts/\" # title will be shown when you hover on this menu link title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" # Markup related configuration in Hugo [markup] # Syntax Highlighting (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false is a necessary configuration (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false Note\rWhen building the website, you can set a theme by using --theme option. However, we suggest you modify the configuration file (config.toml) and set the theme as the default.\r","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.4 Create Your First Post Here is the way to create your first post: hugo new posts/first_post.md Feel free to edit the post file by adding some sample content and replacing the title value in the beginning of the file. Note\rBy default all posts and pages are created as a draft. If you want to render these pages, remove the property draft: true from the metadata, set the property draft: false or add -D/--buildDrafts parameter to hugo command.\r","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.5 Launching the Website Locally Launch by using the following command: hugo serve Go to http://localhost:1313. Basic configuration preview\rTip\rWhen you run hugo serve, when the contents of the files change, the page automatically refreshes with the changes.\rNote\rSince the theme use .Scratch in Hugo to implement some features, it is highly recommended that you add --disableFastRender parameter to hugo server command for the live preview of the page you are editing. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.6 Build the Website When your site is ready to deploy, run the following command: hugo A public folder will be generated, containing all static content and assets for your website. It can now be deployed on any web server. Tip\rThe website can be automatically published and hosted with Netlify (Read more about Automated HUGO deployments with Netlify). Alternatively, you can use AWS Amplify, Github pages, Render and more…\r","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"3 Configuration ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.1 Site Configuration In addition to Hugo global configuration and menu configuration, LoveIt lets you define the following parameters in your site configuration (here is a config.toml, whose values are default). Please open the code block below to view the complete sample configuration : baseURL = \"http://example.org/\" # Change the default theme to be use when building the site with Hugo theme = \"LoveIt\" # website title title = \"My New Hugo Site\" # language code [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"en\" # language name [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"English\" # whether to include Chinese/Japanese/Korean hasCJKLanguage = false # default amount of posts in each pages paginate = 12 # google analytics code [UA-XXXXXXXX-X] googleAnalytics = \"\" # copyright description used only for seo schema copyright = \"\" # whether to use robots.txt enableRobotsTXT = true # whether to use git commit log enableGitInfo = true # whether to use emoji code enableEmoji = true # ignore some build errors ignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"] # Author config [author] name = \"xxxx\" email = \"\" link = \"\" # Menu config [menu] [[menu.main]] weight = 1 identifier = \"posts\" # you can add extra information before the name (HTML format is supported), such as icons pre = \"\" # you can add extra information after the name (HTML format is supported), such as icons post = \"\" name = \"Posts\" url = \"/posts/\" # title will be shown when you hover on this menu link title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" [params] # site default theme [\"auto\", \"light\", \"dark\"] defaultTheme = \"auto\" # public git repo url only then enableGitInfo is true gitRepo = \"\" # which hash function used for SRI, when empty, no SRI is used # [\"sha256\", \"sha384\", \"sha512\", \"md5\"] fingerprint = \"\" # date format dateFormat = \"2006-01-02\" # website title for Open Graph and Twitter Cards title = \"My cool site\" # website description for RSS, SEO, Open Graph and Twitter Cards description = \"This is my cool site\" # website images for Open Graph and Twitter Cards images = [\"/logo.png\"] # Header config [params.header] # desktop header mode [\"fixed\", \"normal\", \"auto\"] desktopMode = \"fixed\" # mobile header mode [\"fixed\", \"normal\", \"auto\"] mobileMode = \"auto\" # Header title config [params.header.title] # URL of the LOGO logo = \"\" # title name name = \"\" # you can add extra information before the name (HTML format is supported), such as icons pre = \"\" # you can add extra information after the name (HTML format is supported), such as icons post = \"\" # whether to use typeit animation for title name typeit = false # Footer config [params.footer] enable = true # Custom content (HTML format is supported) custom = '' # whether to show Hugo and theme info hugo = true # whether to show copyright info copyright = true # whether to show the author author = true # Site creation time since = 2019 # ICP info only in China (HTML format is supported) icp = \"\" # license info (HTML format is supported) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (all posts) page config [params.section] # special amount of posts in each section page paginate = 20 # date format (month and day) dateFormat = \"01-02\" # amount of RSS pages rss = 10 # List (category or tag) page config [params.list] # special amount of posts in each list page paginate = 20 # date format (month and day) dateFormat = \"01-02\" # amount of RSS pages rss = 10 # App icon config [params.app] # optional site title override for the app when added to an iOS home screen or Android launcher title = \"My cool site\" # whether to omit favicon resource links noFavicon = false # modern SVG favicon to use","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.2 Favicons, Browserconfig, Manifest It is recommended to put your own favicons: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) into /static. They’re easily created via https://realfavicongenerator.net/. Customize browserconfig.xml and site.webmanifest to set theme-color and background-color. ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.3 Style Customization Note\rHugo extended version is necessary for the style customization.\rLoveIt theme has been built to be as configurable as possible by defining custom .scss style files. The directory including the custom .scss style files is assets/css relative to your project root directory. In assets/css/_override.scss, you can override the variables in themes/LoveIt/assets/css/_variables.scss to customize the style. Here is a example: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; In assets/css/_custom.scss, you can add some css style code to customize the style. ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"4 Multilingual and i18n LoveIt theme is fully compatible with Hugo multilingual mode, which provides in-browser language switching. Language Switch\r","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.1 Compatibility Language Hugo Code HTML lang Attribute Theme Docs Lunr.js Support English en en Simplified Chinese zh-cn zh-CN Traditional Chinese zh-tw zh-TW French fr fr Polish pl pl Brazilian Portuguese pt-br pt-BR Italian it it Spanish es es German de de German de de Serbian sr sr Russian ru ru Romanian ro ro Vietnamese vi vi Arabic ar ar Catalan ca ca Thai th th Telugu te te Indonesian id id Turkish tr tr Korean ko ko Hindi hi hi ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.2 Basic Configuration After learning how Hugo handle multilingual websites, define your languages in your site configuration. For example with English, Chinese and French website: # determines default content language [\"en\", \"zh-cn\", \"fr\", \"pl\", ...] defaultContentLanguage = \"en\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" [[languages.en.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" [[languages.en.menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" languageCode = \"zh-CN\" languageName = \"简体中文\" hasCJKLanguage = true [[languages.zh-cn.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" [[languages.zh-cn.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[languages.zh-cn.menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" [[languages.fr.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" [[languages.fr.menu.main]] weight = 3 identifier = \"categories\" name = \"Catégories\" pre = \"\" post = \"\" url = \"/categories/\" title = \"\" Then, for each new page, append the language code to the file name. Single file my-page.md is split in three files: in English: my-page.en.md in Chinese: my-page.zh-cn.md in French: my-page.fr.md Note\rBe aware that only translated pages are displayed in menu. It’s not replaced with default language content.\rTip\rUse Front Matter parameter to translate urls too.\r","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.3 Overwrite Translation Strings Translations strings are used for common default values used in the theme. Translations are available in some languages, but you may use another language or want to override default values. To override these values, create a new file in your local i18n folder i18n/\u003clanguageCode\u003e.toml and inspire yourself from themes/LoveIt/i18n/en.toml. By the way, as these translations could be used by other people, please take the time to propose a translation by  making a PR to the theme! ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"5 Search Based on Lunr.js or algolia, searching is supported in LoveIt theme. ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.1 Output Configuration In order to generate index.json for searching, add JSON output file type to the home of the outputs part in your site configuration. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.2 Search Configuration Based on index.json generated by Hugo, you could activate searching. Here is the search configuration in your site configuration: [params.search] enable = true # type of search engine [\"lunr\", \"algolia\"] type = \"lunr\" # max index length of the chunked content contentLength = 4000 # placeholder of the search bar placeholder = \"\" # max number of results length maxResultLength = 10 # snippet length of the result snippetLength = 30 # HTML tag name of the highlight part in results highlightTag = \"em\" # whether to use the absolute URL based on the baseURL in search index absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" How to choose search engine?\rThe following is a comparison of two search engines: lunr: simple, no need to synchronize index.json, no limit for contentLength, but high bandwidth and low performance (Especially for Chinese which needs a large segmentit library) algolia: high performance and low bandwidth, but need to synchronize index.json and limit for contentLength The content of the post is separated by h2 and h3 HTML tag to improve query performance and basically implement full-text search. contentLength is used to limit the max index length of the part starting with h2 and h3 HTML tag. Tips about algolia\rYou need to upload index.json files to algolia to activate searching. You could upload the index.json files by browsers but a CLI tool may be better. The official Algolia CLI is a good choice. To be compatible with Hugo multilingual mode, you need to upload different index.json for each language to the different index of algolia, such as zh-cn/index.json or fr/index.json…\r","date":"2020-03-06","objectID":"/techBlog/posts/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"Theme Documentation - Basics","uri":"/techBlog/posts/theme-documentation-basics/"},{"categories":null,"content":"About LoveIt","date":"2019-08-02","objectID":"/techBlog/about/","tags":null,"title":"About LoveIt","uri":"/techBlog/about/"},{"categories":null,"content":"  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by  Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveIt\r","date":"2019-08-02","objectID":"/techBlog/about/:0:0","tags":null,"title":"About LoveIt","uri":"/techBlog/about/"},{"categories":null,"content":"Features ","date":"2019-08-02","objectID":"/techBlog/about/:1:0","tags":null,"title":"About LoveIt","uri":"/techBlog/about/"},{"categories":null,"content":"Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Plausible Analytics supported  Yandex Metrica supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes ","date":"2019-08-02","objectID":"/techBlog/about/:1:1","tags":null,"title":"About LoveIt","uri":"/techBlog/about/"},{"categories":null,"content":"Appearance and Layout  Desktop/Mobile responsive layout  Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation ","date":"2019-08-02","objectID":"/techBlog/about/:1:2","tags":null,"title":"About LoveIt","uri":"/techBlog/about/"},{"categories":null,"content":"Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 73 social links supported  Up to 24 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  utterances comment system supported by utterances  giscus comment system supported by giscus ","date":"2019-08-02","objectID":"/techBlog/about/:1:3","tags":null,"title":"About LoveIt","uri":"/techBlog/about/"},{"categories":null,"content":"Extended Features  Search supported by Lunr.js or algolia  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightGallery  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $\\KaTeX$  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Cookie consent banner supported by cookieconsent  Person shortcode … ","date":"2019-08-02","objectID":"/techBlog/about/:1:4","tags":null,"title":"About LoveIt","uri":"/techBlog/about/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. ","date":"2019-08-02","objectID":"/techBlog/about/:2:0","tags":null,"title":"About LoveIt","uri":"/techBlog/about/"},{"categories":null,"content":"Special Thanks Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css autocomplete Lunr.js algoliasearch lazysizes object-fit-images Twemoji emoji-data lightGallery clipboard.js Sharer.js TypeIt $\\KaTeX$ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/techBlog/about/:3:0","tags":null,"title":"About LoveIt","uri":"/techBlog/about/"}]